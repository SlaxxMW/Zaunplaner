<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#A1C51D" />
  <title>Arbeitszeiterfassung</title>
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" href="icons/icon-192.png" />
  <style>
:root{
  --brand-green:#8DAB18;
  --brand-green-dark:#6E8712;
  --brand-red:#C4111F;
  --brand-red-dark:#8A1018;
  --bg:#efefef;
  --card:#ffffff;
  --line:#d7d7d7;
  --text:#111;
  --muted:#666;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  background: var(--bg);
  color: var(--text);
  overflow-x:hidden;
}

.hidden{display:none !important;}

.appbar{
  position:sticky;
  top:0;
  z-index:50;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 12px;
  background:#111;
  color:#fff;
}
.app-title{font-weight:700; font-size:18px; line-height:1.1}
.app-subtitle{font-size:12px; opacity:.8; margin-top:2px}
.appbar-left{display:flex; flex-direction:column}
.appbar-right{display:flex; gap:8px}
.icon-btn{
  appearance:none; border:0; background:transparent; color:#fff;
  font-size:18px; padding:8px 10px; border-radius:8px; cursor:pointer;
}
.icon-btn:hover{background:rgba(255,255,255,.12)}

.update-banner{
  position:sticky;
  top:52px;
  z-index:49;
  background:var(--brand-green);
  color:#111;
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  padding:8px 12px;
  border-bottom:3px solid var(--brand-red);
}
.update-text{font-weight:700}

.main{max-width:720px; margin:0 auto; padding:10px 10px 40px}
.month-header{
  position:sticky;
  top:0; /* will sit under banner because banner sticky with top:52px */
  z-index:40;
  display:grid;
  grid-template-columns: 1fr 1.6fr;
  gap:0;
  border:2px solid var(--line);
  border-top:4px solid var(--brand-green);
  background:var(--card);
}
.mh-left{
  background:#eaf3d2;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  padding:12px 10px;
  border-right:2px solid var(--line);
}
.mh-company{
  font-weight:800;
  font-size:20px;
  letter-spacing:.2px;
}
.mh-person{
  margin-top:6px;
  font-weight:800;
  font-size:14px;
  color:#222;
}
.mh-right{
  background:#f1f8df;
  padding:10px 10px 8px;
}
.mh-monthrow{
  display:grid;
  grid-template-columns: 44px 1fr 44px;
  align-items:center;
  gap:6px;
}
.nav-btn{
  appearance:none; border:1px solid var(--brand-green-dark);
  background:#eaf3d2;
  border-radius:10px;
  height:36px;
  font-size:22px;
  cursor:pointer;
}
.nav-btn:active{transform:scale(.98)}
.mh-month{
  text-align:center;
  font-weight:800;
  font-size:20px;
}
.mh-stats{margin-top:8px; display:grid; gap:4px}
.stat-row{display:flex; justify-content:space-between; font-size:14px}
.stat-val{font-weight:800}
.stat-val.good{color:var(--brand-green-dark)}
.stat-val.bad{color:var(--brand-red)}
.mh-actions{margin-top:8px; display:flex; gap:8px; justify-content:flex-end}

.btn{
  appearance:none; border:1px solid #bbb;
  background:#f7f7f7;
  border-radius:12px;
  padding:9px 12px;
  font-weight:700;
  cursor:pointer;
}
.btn:active{transform:scale(.98)}
.btn-light{background:#f7f7f7}
.btn-primary{
  background:var(--brand-green);
  border-color:var(--brand-green-dark);
  color:#111;
}
.btn-danger{
  background:var(--brand-red);
  border-color:var(--brand-red-dark);
  color:#fff;
}

.list{margin-top:8px; border:2px solid var(--line); border-radius:12px; overflow:hidden; background:var(--card)}
.day-card{
  border-bottom:1px solid var(--line);
  background:#fff;
}
.day-card:last-child{border-bottom:0}
.day-item{
  display:grid;
  grid-template-columns: 1fr 120px;
  gap:10px;
  padding:10px 12px;
  cursor:pointer;
  background:#fff;
}
.day-card.open .day-item{
  background:#e3f1c0;
}
.day-card.open{
  border-left:6px solid var(--brand-green);
}
.day-left .d1{font-weight:800; font-size:16px}
.day-left .d2{color:#222; margin-top:2px}
.day-left .d3{color:var(--muted); margin-top:6px}
.day-right{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  justify-content:center;
  gap:4px;
}
.hbig{font-weight:900; font-size:22px}
.hdiff{font-weight:900}
.hdiff.good{color:var(--brand-green-dark)}
.hdiff.bad{color:var(--brand-red)}
.badge{
  font-size:12px;
  font-weight:800;
  padding:2px 8px;
  border-radius:999px;
  border:1px solid #b9cf77;
  background:#eaf3d2;
  margin-left:6px;
}

.day-editor-inline{
  padding:10px 12px 12px;
  border-top:1px solid var(--line);
  background:#fff;
}
.day-editor-inline .inline-head{
  display:flex; justify-content:space-between; align-items:center;
  margin-bottom:10px;
}
.day-editor-inline .inline-meta{font-weight:900; color:#222}
.day-editor-inline .inline-grid{display:grid; gap:10px}
.inline-row{display:grid; grid-template-columns: 90px 1fr; gap:10px; align-items:center}
.inline-row.times{grid-template-columns: 90px 1fr 50px 1fr}
.inline-row label{font-weight:900; color:#222}
.inline-row .mid{font-weight:900; text-align:center; color:#444}
.inline-row input, .inline-row select{
  width:100%; padding:8px 10px; border:1px solid #bbb; border-radius:10px; font-size:15px;
}
.inline-row textarea{
  width:100%; padding:8px 10px; border:1px solid #bbb; border-radius:10px; font-size:15px; resize:vertical;
}
.inline-actions{display:flex; gap:8px; margin-top:10px; justify-content:flex-end; flex-wrap:wrap}
.inline-actions .spacer{flex:1}
.inline-hint{font-size:12px; color:var(--muted); margin-top:-6px; margin-left:100px}

.editor{
  margin-top:10px;
  border:2px solid var(--line);
  border-radius:12px;
  overflow:hidden;
  background: var(--card);
}
.editor-top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 12px;
  background:#ededed;
  border-bottom:0;
}
.editor-title{font-weight:900}
.editor-week{font-weight:800; color:#444}
.editor-grid{display:grid; gap:10px; padding:10px 12px}
.editor-block{
  border:1px solid var(--line);
  border-radius:12px;
  padding:10px;
  background:#fff;
}
.block-title{font-weight:900; margin-bottom:8px}
.row{
  display:grid;
  grid-template-columns: 90px 1fr 50px 1fr;
  gap:8px;
  align-items:center;
  margin-bottom:8px;
}
.row label{font-weight:800; color:#222}
.row label.mid{text-align:center; color:#444}
.row input, .row select{
  width:100%;
  padding:8px 10px;
  border:1px solid #bbb;
  border-radius:10px;
  font-size:15px;
}
.row input[type="text"]{grid-column:2 / span 3}
.editor-block textarea{
  width:100%;
  padding:8px 10px;
  border:1px solid #bbb;
  border-radius:10px;
  resize:vertical;
  font-size:15px;
}
.hint{font-size:12px; color:#555; margin-top:-2px}
.suffix{font-weight:900}
.editor-actions{
  display:flex;
  gap:8px;
  padding:10px 12px;
  border-top:1px solid var(--line);
  background:#fafafa;
}
.spacer{flex:1}

.yearview{margin-top:10px}
.yearview-head{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 0;
}
.year-title{font-weight:900; font-size:18px}
.year-cards{
  display:grid;
  gap:10px;
}
.year-card{
  background:#fff;
  border:2px solid var(--line);
  border-radius:12px;
  padding:10px 12px;
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}
.year-card .mname{font-weight:900}
.year-card .vals{display:grid; gap:4px}
.year-summary{
  margin-top:10px;
  background:#fff;
  border:2px solid var(--line);
  border-radius:12px;
  padding:10px 12px;
}

.modal{
  position:fixed;
  inset:0;
  z-index:200;
  background: rgba(0,0,0,.4);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:14px;
}
.modal-card{
  width:min(680px, 100%);
  max-height: 90vh;
  overflow-y:auto;
  overflow-x:hidden;
  background:#fff;
  border-radius:16px;
  border:3px solid var(--brand-red);
}
.modal-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 12px;
  background: #eee;
  border-bottom:0;
}
.modal-title{font-weight:900}
.modal-body{padding:12px}
.modal-footer{
  padding:10px 12px;
  border-top:1px solid var(--line);
  background:#fafafa;
  display:flex;
  justify-content:flex-end;
}

.form-row{margin-bottom:12px}
.form-row label{display:block; font-weight:900; margin-bottom:6px}
.form-row input, .form-row select{
  width:100%;
  padding:8px 10px;
  border:1px solid #bbb;
  border-radius:10px;
  font-size:15px;
}
.form-row input[type="file"]{max-width:100%}
.small{font-size:12px; color:#555; margin-top:6px}
.btn-row{display:flex; flex-wrap:wrap; gap:8px}
.toggle{display:flex; align-items:center; gap:8px; font-weight:800; justify-content:flex-start; flex-wrap:nowrap}
.toggle input{transform:scale(1.25); width:auto !important; padding:0 !important; border:0 !important; background:transparent !important; box-shadow:none !important; margin:0 !important;}

.toggle input[type="checkbox"]{accent-color:var(--brand-green-dark);} 
.holiday-box{
  border:1px solid var(--line);
  border-radius:12px;
  padding:10px;
  background:#fafafa;
  max-height:220px;
  overflow:auto;
  font-size:13px;
  white-space:pre-wrap;
}
.import-preview{
  border:1px solid var(--line);
  border-radius:12px;
  background:#fafafa;
  padding:10px;
  max-height:240px;
  overflow:auto;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size:12px;
  white-space:pre;
}

.toast{
  position:fixed;
  left:50%;
  bottom:16px;
  transform:translateX(-50%);
  z-index:300;
  background:#111;
  color:#fff;
  padding:10px 12px;
  border-radius:12px;
  max-width:min(680px, 92vw);
  font-weight:800;
}

@media (max-width:520px){
  .month-header{grid-template-columns: 1fr 1.4fr}
  .day-item{grid-template-columns: 1fr 110px}
  .row{grid-template-columns: 80px 1fr 40px 1fr}
  .import-preview{white-space:pre-wrap; word-break:break-word}
}


.day-editor{
  padding:10px 12px 12px;
  border-top:1px solid var(--line);
  background:#fff;
}
.day-editor .meta{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-bottom:8px;
}
.day-editor .meta .small{
  color:var(--muted);
  font-weight:700;
  font-size:12px;
}
.day-editor .grid{
  display:grid;
  gap:10px;
}
.day-editor .block{
  border:1px solid var(--line);
  border-radius:12px;
  padding:10px;
  background:#fff;
}
.day-editor .block-title{
  font-weight:900;
  margin-bottom:8px;
}
.day-editor .row{
  display:grid;
  grid-template-columns: 90px 1fr 50px 1fr;
  gap:8px;
  align-items:center;
  margin-bottom:8px;
}
.day-editor .row label{
  font-weight:800;
  color:#222;
}
.day-editor .row label.mid{
  text-align:center;
  color:#444;
}
.day-editor input, .day-editor select, .day-editor textarea{
  width:100%;
  padding:8px 10px;
  border:1px solid #bbb;
  border-radius:10px;
  font-size:15px;
}
.day-editor textarea{
  resize:vertical;
}
.day-editor .row input[type="text"]{
  grid-column:2 / span 3;
}
.day-editor .actions{
  display:flex;
  gap:8px;
  margin-top:10px;
  justify-content:flex-end;
}
.day-editor .actions .spacer{
  flex:1;
}


/* --- v1.6.1 mobile fixes (settings + csv import cancel) --- */
.modal-card{
  -webkit-overflow-scrolling: touch;
  max-width: calc(100vw - 28px);
}
.modal-body{ overflow-x:hidden; }
.form-row{ max-width:100%; overflow:hidden; }
.form-row input[type="file"]{
  width:100%;
  max-width:100%;
  display:block;
}
.toggle{ flex-wrap:wrap; }

#importModal .modal-footer{
  justify-content: space-between;
  gap:10px;
}

@media (max-width: 420px){
  .modal{ padding:10px; }
  .modal-card{ border-width:2px; }
}

</style>
</head>
<body>
  <header class="appbar">
    <div class="appbar-left">
      <div class="app-title">Arbeitszeiterfassung</div>
      <div class="app-subtitle" id="appVersion"></div>
    </div>
    <div class="appbar-right">
      <button class="icon-btn" id="btnSettings" title="Einstellungen"><span>üîß</span></button>
    </div>
  </header>

  <div class="update-banner hidden" id="updateBanner">
    <div class="update-text" id="updateText">Update verf√ºgbar</div>
    <button class="btn btn-primary" id="btnUpdateNow">Aktualisieren</button>
  </div>

  <main class="main">
    <section class="month-header" id="monthHeader">
      <div class="mh-left">
        <div class="mh-company" id="companyName">Zaunteam</div>
        <div class="mh-person" id="personNameHeader"></div>
      </div>
      <div class="mh-right">
        <div class="mh-monthrow">
          <button class="nav-btn" id="btnPrevMonth" title="Vorheriger Monat">‚Äπ</button>
          <div class="mh-month" id="monthLabel">‚Äî</div>
          <button class="nav-btn" id="btnNextMonth" title="N√§chster Monat">‚Ä∫</button>
        </div>
        <div class="mh-stats">
          <div class="stat-row"><span>Soll-Stunden</span><span class="stat-val" id="statSoll">0,00 h</span></div>
          <div class="stat-row"><span>Ist-Stunden</span><span class="stat-val" id="statIst">0,00 h</span></div>
          <div class="stat-row"><span>S. Vormonat</span><span class="stat-val" id="statCarry">0,00 h</span></div>
          <div class="stat-row"><span>Saldo</span><span class="stat-val" id="statSaldo">0,00 h</span></div>
          <div class="stat-row"><span>Urlaub</span><span class="stat-val" id="statVac">0/30</span></div>
          <div class="stat-row"><span>Krank</span><span class="stat-val" id="statSick">0 Tg</span></div>
</div>
        <div class="mh-actions">
          <button class="btn btn-light" id="btnYearView">Jahr</button>
          <button class="btn btn-light" id="btnToday">Heute</button>
        </div>
      </div>
    </section>

    <section class="list" id="dayList" aria-label="Tage Liste"></section>

    <section class="yearview hidden" id="yearView">
      <div class="yearview-head">
        <div class="year-title" id="yearTitle">Jahr ‚Äî</div>
        <div class="year-actions">
          <button class="btn btn-light" id="btnBackToMonth">Zur√ºck</button>
        </div>
      </div>
      <div class="year-cards" id="yearCards"></div>
      <div class="year-summary" id="yearSummary"></div>
    </section>
  </main>

  <div class="modal hidden" id="settingsModal" role="dialog" aria-modal="true">
    <div class="modal-card">
      <div class="modal-header">
        <div class="modal-title">Einstellungen</div>
        <button class="icon-btn" id="btnCloseSettings" title="Schlie√üen">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="form-row">
          <label>Firma</label>
          <input type="text" id="setCompany" />
        </div>
        <div class="form-row">
          <label>Name (Export/PDF)</label>
          <input type="text" id="setPerson" />
        </div>

        <div class="form-row">
          <label>Letztes Backup</label>
          <div class="small" id="lastBackupInfo">‚Äî</div>
        </div>

        <div class="form-row">
          <label>Bundesland (Feiertage)</label>
          <select id="setState"></select>
        </div>

        <div class="form-row">
          <label>Mari√§ Himmelfahrt</label>
          <label class="toggle"><input type="checkbox" id="setAssumption" /> <span>aktiv</span></label>
        </div>
        <div class="form-row">
          <label>Augsburger Friedensfest</label>
          <label class="toggle"><input type="checkbox" id="setAugsburg" /> <span>aktiv</span></label>
        </div>

        <div class="form-row">
          <label>Urlaub/Jahr</label>
          <input type="number" id="setVacationPerYear" min="0" step="1" />
        </div>

        <div class="form-row">
          <label>Startsaldo Jahr (Stunden)</label>
          <input type="number" id="setYearStartSaldo" step="0.25" />
          <div class="small">Gilt f√ºr das aktuell ausgew√§hlte Jahr.</div>
        </div>


        <div class="form-row">
          <label>Jahres-CSV Monatswerte verwenden</label>
          <label class="toggle"><input type="checkbox" id="setUseYearSummaryMonthly" /> <span>aktiv</span></label>
          <div class="small">Wenn eine Jahres-CSV importiert wurde, werden Soll/Ist/S. Vormonat/Saldo aus der CSV angezeigt.</div>
        </div>

        <hr />

        <div class="form-row">
          <label>Import CSV</label>
          <input type="file" id="fileImportCsv" accept=".csv,text/csv" />
          <div class="small">Nach Auswahl erscheint eine Import-Vorschau.</div>
        </div>

        <div class="form-row">
          <label>Export</label>
          <div class="btn-row">
            <button class="btn btn-light" id="btnExportCsvMonth">CSV Monat</button>
            <button class="btn btn-light" id="btnExportCsvYear">CSV Jahr</button>
            <button class="btn btn-light" id="btnExportPdfMonth">PDF Monat</button>
            <button class="btn btn-light" id="btnExportHandyMonth">Handy Monat</button>
            <button class="btn btn-light" id="btnExportPdfYear">PDF Jahr</button>
            <button class="btn btn-light" id="btnBackupJson">Backup JSON</button>
            <button class="btn btn-light" id="btnRestoreJson">Restore JSON</button>
            <input class="hidden" type="file" id="fileRestoreJson" accept=".json,application/json" />
          </div>
        </div>

        <div class="form-row">
          <label>Update</label>
          <div class="btn-row">
            <button class="btn btn-light" id="btnCheckUpdate">Update suchen</button>
            <button class="btn btn-danger" id="btnCacheReset">Cache/Update-Reset</button>
          </div>
          <div class="small" id="updateInfo"></div>
        </div>

        <div class="form-row">
          <label>Installation (Android)</label>
          <div class="btn-row">
            <button class="btn btn-primary hidden" id="btnInstallApp">App installieren</button>
          </div>
          <div class="small" id="installInfo">‚Äî</div>
        </div>

        <div class="form-row">
          <label>Feiertage Vorschau (aktuelles Jahr)</label>
          <div class="holiday-box" id="holidayPreview">‚Äî</div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-primary" id="btnSaveSettings">Speichern</button>
      </div>
    </div>
  </div>

  <div class="modal hidden" id="importModal" role="dialog" aria-modal="true">
    <div class="modal-card">
      <div class="modal-header">
        <div class="modal-title">CSV Import</div>
        <button class="icon-btn" id="btnCloseImport" title="Schlie√üen">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="small" id="importMeta">‚Äî</div>
        <div class="import-preview" id="importPreview"></div>
        <div class="form-row">
          <label>Konflikte</label>
          <select id="importMode">
            <option value="merge">Zusammenf√ºhren (empfohlen)</option>
            <option value="replace">Ersetzen</option>
          </select>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-light" id="btnCancelImport">Abbrechen</button>
        <button class="btn btn-primary" id="btnConfirmImport">Importieren</button>
      </div>
    </div>
  </div>


  <div class="modal hidden" id="backupModal" role="dialog" aria-modal="true">
    <div class="modal-card">
      <div class="modal-header">
        <div class="modal-title">Backup Erinnerung</div>
        <button class="icon-btn" id="btnCloseBackup" title="Schlie√üen">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="small" id="backupHint">‚Äî</div>
        <div class="btn-row" style="margin-top:10px">
          <button class="btn btn-primary" id="btnBackupNow">Backup jetzt (JSON)</button>
          <button class="btn btn-light" id="btnBackupLater">Sp√§ter</button>
        </div>
      </div>
    </div>
  </div>

  <div class="toast hidden" id="toast"></div>

  <script>
  
  /* ==== db.js ==== */
  /* db.js - IndexedDB wrapper (offline, stable across updates) */
  (function(){
    'use strict';
  
    const DB_NAME = 'az_pwa_db';
    const DB_VERSION = 1;
    const STORE_DAYS = 'days';
    const STORE_SETTINGS = 'settings';
  
    function openDB(){
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(STORE_DAYS)){
            const s = db.createObjectStore(STORE_DAYS, { keyPath: 'date' }); // date: YYYY-MM-DD
            s.createIndex('byDate', 'date', {unique:true});
          }
          if(!db.objectStoreNames.contains(STORE_SETTINGS)){
            db.createObjectStore(STORE_SETTINGS, { keyPath: 'key' });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
  
    async function tx(store, mode, fn){
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const t = db.transaction(store, mode);
        const s = t.objectStore(store);
        let result;
        Promise.resolve(fn(s)).then(r => { result = r; }).catch(reject);
        t.oncomplete = () => resolve(result);
        t.onerror = () => reject(t.error);
        t.onabort = () => reject(t.error);
      });
    }
  
    function getDateKey(d){ return d; }
  
    async function getDay(dateKey){
      return tx(STORE_DAYS, 'readonly', (s) => new Promise((res, rej) => {
        const req = s.get(getDateKey(dateKey));
        req.onsuccess = () => res(req.result || null);
        req.onerror = () => rej(req.error);
      }));
    }
  
    async function setDay(rec){
      // rec: {date, type, start, end, breakH, place, note, updatedAt}
      return tx(STORE_DAYS, 'readwrite', (s) => new Promise((res, rej) => {
        const req = s.put(rec);
        req.onsuccess = () => res(true);
        req.onerror = () => rej(req.error);
      }));
    }
  
    async function deleteDay(dateKey){
      return tx(STORE_DAYS, 'readwrite', (s) => new Promise((res, rej) => {
        const req = s.delete(getDateKey(dateKey));
        req.onsuccess = () => res(true);
        req.onerror = () => rej(req.error);
      }));
    }
  
    async function getRange(startKey, endKey){
      // inclusive range [startKey, endKey]
      return tx(STORE_DAYS, 'readonly', (s) => new Promise((res, rej) => {
        const out = [];
        const req = s.openCursor();
        req.onsuccess = () => {
          const cur = req.result;
          if(cur){
            const k = cur.key;
            if(k >= startKey && k <= endKey) out.push(cur.value);
            cur.continue();
          }else{
            res(out);
          }
        };
        req.onerror = () => rej(req.error);
      }));
    }
  
    async function getAll(){
      return tx(STORE_DAYS, 'readonly', (s) => new Promise((res, rej) => {
        const req = s.getAll();
        req.onsuccess = () => res(req.result || []);
        req.onerror = () => rej(req.error);
      }));
    }
  
    async function getSetting(key, fallback=null){
      return tx(STORE_SETTINGS, 'readonly', (s) => new Promise((res, rej) => {
        const req = s.get(key);
        req.onsuccess = () => res(req.result ? req.result.value : fallback);
        req.onerror = () => rej(req.error);
      }));
    }
  
    async function setSetting(key, value){
      return tx(STORE_SETTINGS, 'readwrite', (s) => new Promise((res, rej) => {
        const req = s.put({key, value});
        req.onsuccess = () => res(true);
        req.onerror = () => rej(req.error);
      }));
    }
  
    async function deleteSetting(key){
      return tx(STORE_SETTINGS, 'readwrite', (s) => new Promise((res, rej) => {
        const req = s.delete(key);
        req.onsuccess = () => res(true);
        req.onerror = () => rej(req.error);
      }));
    }
  
    async function cleanupBefore2025(){
      const cutoff = '2025-01-01';
      // delete day records before cutoff
      await tx(STORE_DAYS, 'readwrite', (s) => new Promise((res, rej) => {
        const req = s.openCursor();
        req.onsuccess = () => {
          const cur = req.result;
          if(cur){
            if(cur.key < cutoff) cur.delete();
            cur.continue();
          }else res(true);
        };
        req.onerror = () => rej(req.error);
      }));
      // remove yearStartSaldo for years < 2025
      const keysToDelete = [];
      await tx(STORE_SETTINGS, 'readonly', (s) => new Promise((res, rej) => {
        const req = s.openCursor();
        req.onsuccess = () => {
          const cur = req.result;
          if(cur){
            const k = cur.key;
            if(typeof k === 'string' && k.startsWith('yearStartSaldo_')){
              const yr = parseInt(k.slice('yearStartSaldo_'.length), 10);
              if(Number.isFinite(yr) && yr < 2025) keysToDelete.push(k);
            }
            cur.continue();
          }else res(true);
        };
        req.onerror = () => rej(req.error);
      }));
      for(const k of keysToDelete){
        await deleteSetting(k);
      }
    }
  
    window.AZDB = {
      openDB,
      getDay,
      setDay,
      deleteDay,
      getRange,
      getAll,
      getSetting,
      setSetting,
      deleteSetting,
      cleanupBefore2025
    };
  })();
  
  
  /* ==== holidays.js ==== */
  /* holidays.js - German public holidays by Bundesland (offline) */
  (function(){
    'use strict';
  
    const STATES = [
      ["BW","Baden-W√ºrttemberg"],
      ["BY","Bayern"],
      ["BE","Berlin"],
      ["BB","Brandenburg"],
      ["HB","Bremen"],
      ["HH","Hamburg"],
      ["HE","Hessen"],
      ["MV","Mecklenburg-Vorpommern"],
      ["NI","Niedersachsen"],
      ["NW","Nordrhein-Westfalen"],
      ["RP","Rheinland-Pfalz"],
      ["SH","Schleswig-Holstein"],
      ["SL","Saarland"],
      ["SN","Sachsen"],
      ["ST","Sachsen-Anhalt"],
      ["TH","Th√ºringen"]
    ];
  
    function pad2(n){ return String(n).padStart(2,'0'); }
    function toKey(d){
      const y = d.getFullYear();
      const m = pad2(d.getMonth()+1);
      const day = pad2(d.getDate());
      return `${y}-${m}-${day}`;
    }
    function fromYMD(y,m,day){ return new Date(Date.UTC(y, m-1, day, 12,0,0)); } // noon UTC
    function addDays(date, days){
      const d = new Date(date.getTime());
      d.setUTCDate(d.getUTCDate()+days);
      return d;
    }
  
    // Meeus/Jones/Butcher algorithm (Gregorian)
    function easterSunday(year){
      const a = year % 19;
      const b = Math.floor(year / 100);
      const c = year % 100;
      const d = Math.floor(b / 4);
      const e = b % 4;
      const f = Math.floor((b + 8) / 25);
      const g = Math.floor((b - f + 1) / 3);
      const h = (19*a + b - d - g + 15) % 30;
      const i = Math.floor(c / 4);
      const k = c % 4;
      const l = (32 + 2*e + 2*i - h - k) % 7;
      const m = Math.floor((a + 11*h + 22*l) / 451);
      const month = Math.floor((h + l - 7*m + 114) / 31); // 3=March, 4=April
      const day = ((h + l - 7*m + 114) % 31) + 1;
      return fromYMD(year, month, day);
    }
  
    function bussUndBettag(year){
      // Wednesday before Nov 23
      const d = fromYMD(year, 11, 23);
      // getUTCDay(): 0=Sun..6=Sat, we need previous Wednesday (3)
      const wd = d.getUTCDay();
      let diff = (wd - 3);
      if(diff < 0) diff += 7;
      return addDays(d, -diff - 7); // Wednesday before the week containing 23rd
    }
  
    function isIn(list, state){ return list.indexOf(state) >= 0; }
  
    function holidaysForYear(year, state, opts){
      opts = opts || {};
      const map = new Map();
  
      const easter = easterSunday(year);
      // Common nationwide holidays
      map.set(toKey(fromYMD(year,1,1)), "Neujahr");
      map.set(toKey(fromYMD(year,5,1)), "Tag der Arbeit");
      map.set(toKey(fromYMD(year,10,3)), "Tag der Deutschen Einheit");
      map.set(toKey(fromYMD(year,12,25)), "1. Weihnachtstag");
      map.set(toKey(fromYMD(year,12,26)), "2. Weihnachtstag");
  
      // Easter-based nationwide
      map.set(toKey(addDays(easter,-2)), "Karfreitag");
      map.set(toKey(addDays(easter,1)), "Ostermontag");
      map.set(toKey(addDays(easter,39)), "Christi Himmelfahrt");
      map.set(toKey(addDays(easter,50)), "Pfingstmontag");
  
      // State-specific fixed
      if(isIn(["BW","BY","ST"], state)) map.set(toKey(fromYMD(year,1,6)), "Heilige Drei K√∂nige");
      if(isIn(["BE","MV"], state)) map.set(toKey(fromYMD(year,3,8)), "Internationaler Frauentag");
      if(isIn(["TH"], state)) map.set(toKey(fromYMD(year,9,20)), "Weltkindertag");
  
      // Reformationstag (Oct 31)
      if(isIn(["BB","HB","HH","MV","NI","SN","ST","SH","TH"], state)) map.set(toKey(fromYMD(year,10,31)), "Reformationstag");
  
      // Allerheiligen (Nov 1)
      if(isIn(["BW","BY","NW","RP","SL"], state)) map.set(toKey(fromYMD(year,11,1)), "Allerheiligen");
  
      // Bu√ü- und Bettag (SN)
      if(state === "SN") map.set(toKey(bussUndBettag(year)), "Bu√ü- und Bettag");
  
      // Easter Sunday / Whit Sunday holidays in some states
      if(state === "BB") map.set(toKey(easter), "Ostersonntag");
      if(state === "BB") map.set(toKey(addDays(easter,49)), "Pfingstsonntag");
  
      // Corpus Christi (Fronleichnam) in some states
      if(isIn(["BW","BY","HE","NW","RP","SL"], state)) map.set(toKey(addDays(easter,60)), "Fronleichnam");
  
      // Mari√§ Himmelfahrt (15 Aug): SL always; BY optional
      if(state === "SL") map.set(toKey(fromYMD(year,8,15)), "Mari√§ Himmelfahrt");
      if(state === "BY" && opts.assumption) map.set(toKey(fromYMD(year,8,15)), "Mari√§ Himmelfahrt");
  
      // Augsburger Friedensfest (8 Aug) - only Augsburg (optional)
      if(state === "BY" && opts.augsburg) map.set(toKey(fromYMD(year,8,8)), "Augsburger Friedensfest");
  
      return map;
    }
  
    function getHolidayName(dateKey, state, opts){
      const y = parseInt(dateKey.slice(0,4), 10);
      const map = holidaysForYear(y, state, opts);
      return map.get(dateKey) || null;
    }
  
    window.AZHolidays = {
      STATES,
      easterSunday,
      holidaysForYear,
      getHolidayName
    };
  })();
  
  
  /* ==== export.js ==== */
  /* export.js - CSV/PDF/JSON import-export */
  (function(){
    'use strict';
  
    function pad2(n){ return String(n).padStart(2,'0'); }
    function formatHours(h){
      const sign = h < 0 ? "-" : "";
      const ah = Math.abs(h);
      return sign + ah.toFixed(2).replace(".", ",") + " h";
    }
    function formatNum(h){
      const sign = h < 0 ? "-" : "";
      const ah = Math.abs(h);
      return sign + ah.toFixed(2).replace(".", ",");
    }
    function parseGermanNumber(s){
      if(s==null) return null;
      const t = String(s).trim();
      if(!t) return null;
      const cleaned = t.replace(/\./g,'').replace(',', '.');
      const v = Number(cleaned);
      return Number.isFinite(v) ? v : null;
    }
  
    function isISODate(s){ return /^\d{4}-\d{2}-\d{2}$/.test(s); }
    function parseDateKey(s){
      const t = String(s||"").trim();
      if(isISODate(t)) return t;
      const m = t.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/);
      if(m){
        const dd = pad2(parseInt(m[1],10));
        const mm = pad2(parseInt(m[2],10));
        const yy = m[3];
        return `${yy}-${mm}-${dd}`;
      }
      const m2 = t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if(m2){
        const dd = pad2(parseInt(m2[1],10));
        const mm = pad2(parseInt(m2[2],10));
        const yy = m2[3];
        return `${yy}-${mm}-${dd}`;
      }
      return null;
    }
  
    function detectDelimiter(line){
      const counts = {
        ';': (line.match(/;/g)||[]).length,
        ',': (line.match(/,/g)||[]).length,
        '\t': (line.match(/\t/g)||[]).length
      };
      let best = ';', bestv = -1;
      for(const k of Object.keys(counts)){
        if(counts[k] > bestv){ bestv = counts[k]; best = k; }
      }
      return bestv <= 0 ? ';' : best;
    }
  
    function splitCsvLine(line, delim){
      const out=[];
      let cur="", inQ=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(ch === '"'){
          if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = !inQ;
        }else if(ch===delim && !inQ){
          out.push(cur); cur="";
        }else{
          cur += ch;
        }
      }
      out.push(cur);
      return out.map(s=>s.trim());
    }
  
    function normalizeHeader(h){
      return String(h||"").trim().toLowerCase()
        .replace(/\s+/g,' ')
        .replace(/√§/g,'ae').replace(/√∂/g,'oe').replace(/√º/g,'ue').replace(/√ü/g,'ss');
    }
  
    function mapType(v){
      const t = String(v||"").trim().toLowerCase();
      if(!t) return null;
      if(t.includes('urlaub')) return 'vac';
      if(t.includes('krank')) return 'sick';
      if(t.includes('feiert')) return 'holiday';
      if(t.includes('ruhe')) return 'rest';
      if(t.includes('zeitaus')) return 'comp';
      if(t.includes('arbeits')) return 'work';
      if(t === 'work') return 'work';
      return null;
    }
  
    function parseYearSummary(lines, delim){
      // Example:
      // Stunden√ºbersicht eines Jahres Markus Wolf;2025;Zaunteam
      const first = splitCsvLine(lines[0], delim);
      const rawName = first[0] || "";
      const name = rawName.replace(/^Stunden√ºbersicht eines Jahres/i,'').trim();
      const year = parseInt((first[1]||"").trim(),10);
      const company = (first[2]||"").trim();
  
      let headerIdx1 = -1;
      for(let i=0;i<lines.length;i++){
        const l = lines[i];
        if(/^Monat/i.test(l) && l.includes("Soll-Stunden") && l.includes("Ist-Stunden") && l.includes("S. Vormonat")){
          headerIdx1 = i;
          break;
        }
      }
      if(headerIdx1 < 0) return {errors:["Jahres-CSV erkannt, aber Monats-Header nicht gefunden."]};
  
      const header1Raw = splitCsvLine(lines[headerIdx1], delim);
      const header1 = header1Raw.map(normalizeHeader);
      const colMonth = header1.findIndex(h=>h==='monat');
      const colSoll = header1.findIndex(h=>h.includes('soll-stunden'));
      const colIst  = header1.findIndex(h=>h.includes('ist-stunden'));
      const colDiff = header1.findIndex(h=>h==='differenz' || h.includes('differenz'));
      const colCarry = header1.findIndex(h=>h.includes('s. vormonat') || h.includes('s.vormonat'));
      const colPaidOT = header1.findIndex(h=>h.includes('bezahlte') && h.includes('ueberstunden'));
      const colSaldo = header1.findIndex(h=>h==='saldo' || h.includes('saldo'));
      if(colMonth<0 || colSoll<0 || colIst<0 || colCarry<0) return {errors:["Monat/Soll/Ist/S. Vormonat Spalten fehlen."]};
  
      const monthMap = {
        "januar":1,"februar":2,"maerz":3,"m√§rz":3,"april":4,"mai":5,"juni":6,"juli":7,
        "august":8,"september":9,"oktober":10,"november":11,"dezember":12
      };
  
      const months = [];
      let total = null;
  
      for(let i=headerIdx1+1;i<lines.length;i++){
        const l = lines[i];
        // second table begins
        if(/^Monat/i.test(l) && l.includes('Arbeitszeit') && l.includes('Ferien/Urlaub')) break;
        const cols = splitCsvLine(l, delim);
        if(cols.length < 2) continue;
        const mName = normalizeHeader(cols[colMonth]||"");
        const obj = {
          name: cols[colMonth],
          soll: parseGermanNumber(cols[colSoll]) ?? 0,
          ist: parseGermanNumber(cols[colIst]) ?? 0,
          diff: colDiff>=0 ? (parseGermanNumber(cols[colDiff]) ?? 0) : 0,
          carry: parseGermanNumber(cols[colCarry]) ?? 0,
          paidOvertime: colPaidOT>=0 ? (parseGermanNumber(cols[colPaidOT]) ?? 0) : 0,
          saldo: colSaldo>=0 ? (parseGermanNumber(cols[colSaldo]) ?? 0) : 0
        };
        if(mName === 'total'){
          total = obj;
          continue;
        }
        if(!monthMap[mName]) continue;
        obj.month = monthMap[mName];
        months.push(obj);
        if(months.length>=12 && total) break;
      }
  
      const jan = months.find(m=>m.month===1);
      const yearStartSaldo = jan && jan.carry!=null ? jan.carry : 0;
  
      // second table: day type counts by month
      let headerIdx2 = -1;
      for(let i=headerIdx1+1;i<lines.length;i++){
        const l = lines[i];
        if(/^Monat/i.test(l) && l.includes('Arbeitszeit') && l.includes('Ferien/Urlaub')){
          headerIdx2 = i;
          break;
        }
      }
  
      let counts = null;
      if(headerIdx2 >= 0){
        const header2Raw = splitCsvLine(lines[headerIdx2], delim).filter(h=>h!=="");
        const headers = header2Raw;
  
        const keys = headers.map(h => {
          const n = normalizeHeader(h)
            .replace(/[^a-z0-9]+/g,'_')
            .replace(/^_+|_+$/g,'');
          return n || 'col';
        });
  
        const months2 = [];
        let totalRaw = null;
        let totalByKey = null;
  
        for(let i=headerIdx2+1;i<lines.length;i++){
          const cols = splitCsvLine(lines[i], delim);
          if(cols.length < 2) continue;
          const m0 = normalizeHeader(cols[0]||"");
          const valuesRaw = {};
          const valuesByKey = {};
          for(let c=0; c<headers.length; c++){
            const rawVal = (cols[c] ?? '').trim();
            valuesRaw[headers[c]] = rawVal;
            const num = parseGermanNumber(rawVal);
            if(num != null) valuesByKey[keys[c]] = num;
          }
  
          if(m0 === 'total'){
            totalRaw = valuesRaw;
            totalByKey = valuesByKey;
            continue;
          }
          if(!monthMap[m0]) continue;
          months2.push({month:monthMap[m0], name:cols[0], valuesRaw, valuesByKey});
          if(months2.length>=12 && totalRaw) break;
        }
  
        counts = {
          headers,
          keys,
          months: months2,
          totalRaw,
          totalByKey
        };
      }
  
      return {
        summary: { kind:"year_summary", year, person:name, company, yearStartSaldo, months, total, counts },
        errors: []
      };
    }
  
    function extractYearFromLines(lines){
      for(const l of lines){
        const m = String(l||'').match(/\b(20\d{2})\b/);
        if(m){
          const y = parseInt(m[1],10);
          if(Number.isFinite(y) && y >= 2000 && y <= 2100) return y;
        }
      }
      return null;
    }
  
    function extractMonthFromLines(lines){
      const monthMap = {
        "januar":1,"februar":2,"maerz":3,"m√§rz":3,"april":4,"mai":5,"juni":6,"juli":7,
        "august":8,"september":9,"oktober":10,"november":11,"dezember":12
      };
      for(const l of lines){
        const n = normalizeHeader(l);
        for(const k of Object.keys(monthMap)){
          if(n.includes(k)) return monthMap[k];
        }
      }
      return null;
    }
  
    // Monats√ºbersicht: speichert Monatswerte kompatibel zum bestehenden year_summary Format
    function parseMonthSummary(lines, delim){
      let person = null;
      let company = null;
      let year = null;
      let month = null;
  
      // Fall A: "Stunden√ºbersicht eines Monats ...;2025;Firma"
      const first = splitCsvLine(lines[0], delim);
      if(/^Stunden√ºbersicht eines Monats/i.test(first[0]||'')){
        const rawName = first[0] || "";
        person = rawName.replace(/^Stunden√ºbersicht eines Monats/i,'').trim() || null;
        const y = parseInt((first[1]||"").trim(),10);
        year = Number.isFinite(y) ? y : null;
        company = (first[2]||"").trim() || null;
      }
  
      // Header suchen: Monat;Soll-Stunden;Ist-Stunden;...;S. Vormonat
      let headerIdx = -1;
      for(let i=0;i<lines.length;i++){
        const l = lines[i];
        if(/^Monat/i.test(l) && /Soll[- ]Stunden/i.test(l) && /Ist[- ]Stunden/i.test(l) && /Vormonat/i.test(l)){
          headerIdx = i;
          break;
        }
      }
      if(headerIdx < 0){
        const l0 = lines[0] || '';
        if(/^Monat/i.test(l0) && /Soll[- ]Stunden/i.test(l0) && /Ist[- ]Stunden/i.test(l0)) headerIdx = 0;
      }
      if(headerIdx < 0) return {errors:["Monats-CSV erkannt/vermuten, aber Monats-Header nicht gefunden."]};
  
      const headerRaw = splitCsvLine(lines[headerIdx], delim);
      const header = headerRaw.map(normalizeHeader);
      const colMonth = header.findIndex(h=>h==='monat');
      const colSoll = header.findIndex(h=>h.includes('soll-stunden'));
      const colIst  = header.findIndex(h=>h.includes('ist-stunden'));
      const colDiff = header.findIndex(h=>h==='differenz' || h.includes('differenz'));
      const colCarry = header.findIndex(h=>h.includes('s. vormonat') || h.includes('s.vormonat') || h.includes('vormonat'));
      const colPaidOT = header.findIndex(h=>h.includes('bezahlte') && h.includes('ueberstunden'));
      const colSaldo = header.findIndex(h=>h==='saldo' || h.includes('saldo'));
      if(colMonth<0 || colSoll<0 || colIst<0) return {errors:["Monat/Soll/Ist Spalten fehlen."]};
  
      const monthMap = {
        "januar":1,"februar":2,"maerz":3,"m√§rz":3,"april":4,"mai":5,"juni":6,"juli":7,
        "august":8,"september":9,"oktober":10,"november":11,"dezember":12
      };
  
      let monthRow = null;
      for(let i=headerIdx+1;i<lines.length;i++){
        const cols = splitCsvLine(lines[i], delim);
        if(cols.length < 2) continue;
        const mNameNorm = normalizeHeader(cols[colMonth]||"");
        if(mNameNorm === 'total') continue;
        const mnum = monthMap[mNameNorm] || null;
        if(!mnum) continue;
        monthRow = {
          month: mnum,
          name: cols[colMonth],
          soll: parseGermanNumber(cols[colSoll]) ?? 0,
          ist: parseGermanNumber(cols[colIst]) ?? 0,
          diff: colDiff>=0 ? (parseGermanNumber(cols[colDiff]) ?? 0) : 0,
          carry: colCarry>=0 ? (parseGermanNumber(cols[colCarry]) ?? 0) : 0,
          paidOvertime: colPaidOT>=0 ? (parseGermanNumber(cols[colPaidOT]) ?? 0) : 0,
          saldo: colSaldo>=0 ? (parseGermanNumber(cols[colSaldo]) ?? 0) : 0
        };
        break;
      }
      if(!monthRow) return {errors:["Keine g√ºltige Monatszeile gefunden (z.B. 'Dezember')."]};
  
      month = monthRow.month;
      if(!year){
        const y = extractYearFromLines(lines);
        if(y) year = y;
      }
      if(!year) return {errors:["Jahr nicht gefunden (bitte CSV mit Jahr exportieren)."]};
      if(!month){
        const m = extractMonthFromLines(lines);
        if(m) month = m;
      }
  
      const yearStartSaldo = (monthRow.month === 1 && monthRow.carry!=null) ? (monthRow.carry || 0) : 0;
  
      return {
        summary: {
          kind:"month_summary",
          year,
          month,
          person,
          company,
          monthRow,
          yearStartSaldo
        },
        errors: []
      };
    }
  
    function parseDaily(lines, delim){
      const headers = splitCsvLine(lines[0], delim);
      const hnorm = headers.map(normalizeHeader);
      const idx = {
        date: hnorm.findIndex(h => h === 'datum' || h === 'date' || h === 'tag' || h.includes('arbeitstag')),
        type: hnorm.findIndex(h => h === 'typ' || h === 'type' || h.includes('status')),
        start: hnorm.findIndex(h => h === 'start' || h.includes('beginn') || h.includes('von')),
        end: hnorm.findIndex(h => h === 'ende' || h.includes('bis')),
        brk: hnorm.findIndex(h => h.includes('pause')),
        place: hnorm.findIndex(h => h === 'ort' || h.includes('baust') || h.includes('stelle') || h.includes('location')),
        note: hnorm.findIndex(h => h.includes('notiz') || h.includes('bemerk') || h.includes('note')),
        breakH: hnorm.findIndex(h => h.includes('pause_h') || h.includes('pause (h)')),
      };
      if(idx.date < 0) return {rows:[], errors:["Spalte 'Datum' nicht gefunden."]};
  
      const errors=[];
      const rows=[];
      for(let i=1;i<lines.length;i++){
        const cols = splitCsvLine(lines[i], delim);
        const dk = parseDateKey(cols[idx.date]);
        if(!dk){ errors.push(`Zeile ${i+1}: Datum ung√ºltig`); continue; }
        if(dk < '2025-01-01'){ continue; }
  
        const rec = { date: dk };
        const t = idx.type>=0 ? mapType(cols[idx.type]) : null;
        if(t) rec.type = t;
  
        const start = idx.start>=0 ? String(cols[idx.start]||"").trim() : "";
        const end = idx.end>=0 ? String(cols[idx.end]||"").trim() : "";
        if(start) rec.start = start;
        if(end) rec.end = end;
  
        let brk = null;
        if(idx.brk>=0){
          brk = parseGermanNumber(cols[idx.brk]);
        }else if(idx.breakH>=0){
          brk = parseGermanNumber(cols[idx.breakH]);
        }
        if(brk != null) rec.breakH = brk;
  
        const place = idx.place>=0 ? String(cols[idx.place]||"").trim() : "";
        if(place) rec.place = place;
  
        const note = idx.note>=0 ? String(cols[idx.note]||"").trim() : "";
        if(note) rec.note = note;
  
        rows.push(rec);
      }
      return {rows, errors};
    }
  
    function parseCsv(text){
      const raw = text.replace(/^\uFEFF/, '');
      let lines = raw.split(/\r?\n/).map(l=>l.trimEnd()).filter(l=>l.trim().length>0);
  
      // Allow meta-header lines on exports (e.g. starting with "## ...").
      // They are ignored for import detection.
      while(lines.length && (/^\s*##/.test(lines[0]) || /^\s*#/.test(lines[0]))){
        lines.shift();
      }
      if(lines.length<2) return {kind:'unknown', rows:[], errors:["CSV hat zu wenig Zeilen."]};
      const delim = detectDelimiter(lines[0]);
  
      // Detect "Jahres√ºbersicht" CSV (like user sample)
      if(/^Stunden√ºbersicht eines Jahres/i.test(lines[0])){
        const ys = parseYearSummary(lines, delim);
        if(ys.errors && ys.errors.length) return {kind:'year_summary', summary:null, errors:ys.errors};
        return {kind:'year_summary', summary:ys.summary, errors:[]};
      }
  
      // Detect "Monats√ºbersicht" CSV (Monatswerte)
      if(
        /^Stunden√ºbersicht eines Monats/i.test(lines[0]) ||
        (/^Monat/i.test(lines[0]) && /Soll[- ]Stunden/i.test(lines[0]) && /Ist[- ]Stunden/i.test(lines[0]) && /Vormonat/i.test(lines[0]))
      ){
        const ms = parseMonthSummary(lines, delim);
        if(ms.errors && ms.errors.length) return {kind:'month_summary', summary:null, errors:ms.errors};
        return {kind:'month_summary', summary:ms.summary, errors:[]};
      }
  
      // Otherwise treat as daily CSV
      const daily = parseDaily(lines, delim);
      return {kind:'daily', rows:daily.rows, errors:daily.errors || []};
    }
  
    function downloadBlob(blob, filename){
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
    }
    function downloadText(text, filename, mime){
      const blob = new Blob([text], {type: mime || 'text/plain;charset=utf-8'});
      downloadBlob(blob, filename);
    }
  
    function buildCsv(rows){
      const header = ["Datum","Wochentag","Typ","Start","Ende","Pause_h","Soll_h","Ist_h","Diff_h","Ort","Notiz"].join(";");
      const lines = [header];
      for(const r of rows){
        lines.push([
          r.datum,
          r.wochentag,
          r.typ,
          r.start||"",
          r.ende||"",
          r.pause_h,
          r.soll_h,
          r.ist_h,
          r.diff_h,
          (r.ort||"").replace(/;/g,','),
          (r.notiz||"").replace(/;/g,',')
        ].join(";"));
      }
      return lines.join("\n");
    }
  
      /* === PATCHPOINT: BUILD_MOBILE_HTML_REPORT === */
    function escapeHtml(s){
      return String(s ?? '')
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }
  
    function buildMobileHtmlReport({ title, subtitle, exportLabel, metaLines, rows }){
      const meta = Array.isArray(metaLines) ? metaLines : [];
      const sumSoll = rows.reduce((a,r)=>a + (parseGermanNumber(r.soll_h)||0), 0);
      const sumIst  = rows.reduce((a,r)=>a + (parseGermanNumber(r.ist_h)||0), 0);
      const sumDiff = rows.reduce((a,r)=>a + (parseGermanNumber(r.diff_h)||0), 0);
  
      const metaBlock = meta.length ? `<pre class="meta">${escapeHtml(meta.join('\n'))}</pre>` : '';
  
      const tableRows = rows.map(r=>`
        <tr>
          <td class="c-date">${escapeHtml(r.datum)}</td>
          <td class="c-day">${escapeHtml(r.wochentag)}</td>
          <td class="c-type">${escapeHtml(r.typ)}</td>
          <td class="c-time">${escapeHtml(r.start||'')}</td>
          <td class="c-time">${escapeHtml(r.ende||'')}</td>
          <td class="c-num">${escapeHtml(r.pause_h||'')}</td>
          <td class="c-num">${escapeHtml(r.soll_h||'')}</td>
          <td class="c-num strong">${escapeHtml(r.ist_h||'')}</td>
          <td class="c-num ${parseGermanNumber(r.diff_h)<0?'neg':'pos'}">${escapeHtml(r.diff_h||'')}</td>
          <td class="c-text">${escapeHtml(r.ort||'')}</td>
          <td class="c-text">${escapeHtml(r.notiz||'')}</td>
        </tr>
      `).join('');
  
      const cards = rows.map(r=>{
        const time = (r.start && r.ende) ? `${r.start}‚Äì${r.ende}` : '‚Äî';
        const pause = (r.typ === 'Arbeitszeit' && r.pause_h) ? ` ‚Ä¢ Pause ${r.pause_h} h` : '';
        const ort = r.ort ? ` ‚Ä¢ ${r.ort}` : '';
        const note = r.notiz ? `<div class="note">${escapeHtml(r.notiz)}</div>` : '';
        const diffNum = parseGermanNumber(r.diff_h);
        const diffClass = diffNum < 0 ? 'neg' : 'pos';
        return `
          <div class="card">
            <div class="card-top">
              <div class="date">${escapeHtml(r.datum)} <span class="day">${escapeHtml(r.wochentag)}</span></div>
              <div class="type">${escapeHtml(r.typ)}</div>
            </div>
            <div class="line">${escapeHtml(time)}${escapeHtml(pause)}${escapeHtml(ort)}</div>
            <div class="grid">
              <div><span class="k">Ist</span><span class="v strong">${escapeHtml(r.ist_h)} h</span></div>
              <div><span class="k">Soll</span><span class="v">${escapeHtml(r.soll_h)} h</span></div>
              <div><span class="k">Diff</span><span class="v ${diffClass}">${escapeHtml(r.diff_h)} h</span></div>
            </div>
            ${note}
          </div>
        `;
      }).join('');
  
      const html = `<!doctype html>
  <html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${escapeHtml(title || 'Arbeitszeiterfassung')} ‚Äì ${escapeHtml(exportLabel || '')}</title>
    <style>
      :root{
        --bg:#0b1220;
        --card:#111a2e;
        --muted:#93a4c7;
        --text:#e8eefc;
        --brand:#2e7d32;
        --line:rgba(255,255,255,.08);
        --neg:#ff6b6b;
        --pos:#54d38a;
      }
      *{ box-sizing:border-box; }
      body{ margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
      .wrap{ max-width:980px; margin:0 auto; padding:14px; }
      .head{
        background: linear-gradient(135deg, rgba(46,125,50,.95), rgba(46,125,50,.55));
        border:1px solid rgba(255,255,255,.15);
        border-radius:16px;
        padding:14px 14px 12px;
        box-shadow: 0 10px 28px rgba(0,0,0,.25);
      }
      .title{ font-size:18px; font-weight:800; letter-spacing:.2px; }
      .sub{ margin-top:4px; color:rgba(255,255,255,.92); font-size:13px; line-height:1.25; }
      .label{ margin-top:10px; font-size:13px; color:rgba(255,255,255,.9); }
      .totals{
        margin-top:12px;
        display:grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap:10px;
      }
      .tbox{
        background: rgba(17,26,46,.65);
        border: 1px solid rgba(255,255,255,.14);
        border-radius:14px;
        padding:10px 10px;
      }
      .tbox .k{ color: rgba(255,255,255,.85); font-size:12px; }
      .tbox .v{ font-size:18px; font-weight:900; margin-top:2px; }
      .meta{
        margin:12px 0 0;
        padding:10px 12px;
        border-radius:14px;
        border:1px dashed rgba(255,255,255,.22);
        background: rgba(17,26,46,.45);
        color: var(--muted);
        white-space: pre-wrap;
        font-size:12px;
        line-height:1.3;
      }
  
      /* desktop table */
      .table-wrap{
        margin-top:14px;
        background: rgba(17,26,46,.55);
        border:1px solid rgba(255,255,255,.12);
        border-radius:16px;
        overflow:hidden;
      }
      table{ width:100%; border-collapse:collapse; font-size:12.5px; }
      thead th{
        position: sticky; top:0;
        background: rgba(17,26,46,.98);
        border-bottom: 1px solid var(--line);
        text-align:left;
        padding:10px 10px;
        font-weight:800;
        color: rgba(255,255,255,.92);
        white-space:nowrap;
        z-index:2;
      }
      tbody td{
        padding:9px 10px;
        border-bottom:1px solid var(--line);
        vertical-align:top;
      }
      tbody tr:nth-child(even){ background: rgba(255,255,255,.03); }
      .c-num{ text-align:right; font-variant-numeric: tabular-nums; white-space:nowrap; }
      .c-time{ text-align:center; font-variant-numeric: tabular-nums; white-space:nowrap; }
      .c-date{ white-space:nowrap; }
      .c-text{ max-width: 260px; }
      .strong{ font-weight:900; }
      .neg{ color: var(--neg); font-weight:900; }
      .pos{ color: var(--pos); font-weight:900; }
  
      /* phone cards */
      .cards{ display:none; margin-top:14px; }
      .card{
        background: rgba(17,26,46,.65);
        border:1px solid rgba(255,255,255,.12);
        border-radius:16px;
        padding:12px 12px 10px;
        margin-bottom:10px;
      }
      .card-top{ display:flex; justify-content:space-between; gap:10px; align-items:flex-start; }
      .date{ font-weight:900; }
      .day{ color: var(--muted); font-weight:700; margin-left:6px; }
      .type{ font-weight:900; color: rgba(255,255,255,.92); text-align:right; }
      .line{ margin-top:6px; color: var(--muted); font-size:12.5px; }
      .grid{
        margin-top:10px;
        display:grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap:8px;
      }
      .grid .k{ display:block; color: var(--muted); font-size:11px; }
      .grid .v{ display:block; font-variant-numeric: tabular-nums; font-size:14px; margin-top:1px; }
      .note{
        margin-top:10px;
        padding-top:10px;
        border-top:1px dashed rgba(255,255,255,.14);
        color: rgba(255,255,255,.92);
        font-size:12.5px;
        white-space:pre-wrap;
      }
  
      @media (max-width: 720px){
        .table-wrap{ display:none; }
        .cards{ display:block; }
        .totals{ grid-template-columns: 1fr; }
        .tbox .v{ font-size:20px; }
      }
  
      @media print{
        body{ background:#fff; color:#000; }
        .head{ background:#eee; color:#000; border-color:#ddd; box-shadow:none; }
        .meta{ background:#fff; color:#444; }
        .table-wrap{ display:block; border-color:#ddd; }
        thead th{ background:#f5f5f5; color:#000; border-color:#ddd; position: static; }
        tbody td{ border-color:#eee; }
        .cards{ display:none !important; }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="head">
        <div class="title">${escapeHtml(title || 'Arbeitszeiterfassung')}</div>
        <div class="sub">${escapeHtml(subtitle || '')}</div>
        <div class="label">${escapeHtml(exportLabel || '')}</div>
        <div class="totals">
          <div class="tbox"><div class="k">Summe Ist</div><div class="v">${formatNum(sumIst)} h</div></div>
          <div class="tbox"><div class="k">Summe Soll</div><div class="v">${formatNum(sumSoll)} h</div></div>
          <div class="tbox"><div class="k">Summe Diff</div><div class="v">${formatNum(sumDiff)} h</div></div>
        </div>
        ${metaBlock}
      </div>
  
      <div class="cards">
        ${cards}
      </div>
  
      <div class="table-wrap">
        <div style="overflow:auto; max-width:100%;">
          <table>
            <thead>
              <tr>
                <th>Datum</th>
                <th>Tag</th>
                <th>Typ</th>
                <th>Start</th>
                <th>Ende</th>
                <th>Pause</th>
                <th>Soll</th>
                <th>Ist</th>
                <th>Diff</th>
                <th>Ort</th>
                <th>Notiz</th>
              </tr>
            </thead>
            <tbody>
              ${tableRows}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </body>
  </html>`;
      return html;
    }
  
  function escapePdfText(s){
      return String(s||"").replace(/\\/g,'\\\\').replace(/\(/g,'\\(').replace(/\)/g,'\\)');
    }
  
    function createSimplePdf(title, subtitle, lines){
      const PAGE_W = 595.28, PAGE_H = 841.89;
      const marginX = 36;
      const startY = 785;
      const lineH = 12.5;
      const maxLines = Math.floor((startY - 60) / lineH);
      const pages = [];
      for(let i=0;i<lines.length;i+=maxLines) pages.push(lines.slice(i, i+maxLines));
  
      const objects = [];
      function addObj(str){ objects.push(str); return objects.length; }
      const fontObjNum = addObj("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>");
  
      const pageObjs = [];
      for(let p=0;p<pages.length;p++){
        const contentLines = [];
        contentLines.push("q");
        contentLines.push("0.631 0.773 0.114 rg");
        contentLines.push(`0 ${PAGE_H-40} ${PAGE_W} 40 re f`);
        contentLines.push("Q");
  
        contentLines.push("BT");
        contentLines.push(`/F1 16 Tf`);
        contentLines.push(`${marginX} ${PAGE_H-28} Td`);
        contentLines.push(`(${escapePdfText(title)}) Tj`);
        contentLines.push("ET");
  
        if(subtitle){
          contentLines.push("BT");
          contentLines.push(`/F1 10 Tf`);
          contentLines.push(`${marginX} ${PAGE_H-46} Td`);
          contentLines.push(`(${escapePdfText(subtitle)}) Tj`);
          contentLines.push("ET");
        }
  
        let y = startY;
        for(const line of pages[p]){
          contentLines.push("BT");
          contentLines.push(`/F1 10 Tf`);
          contentLines.push(`${marginX} ${y} Td`);
          contentLines.push(`(${escapePdfText(line)}) Tj`);
          contentLines.push("ET");
          y -= lineH;
        }
        const stream = contentLines.join("\n");
        const contentObjNum = addObj(`<< /Length ${stream.length} >>\nstream\n${stream}\nendstream`);
        const pageObjNum = addObj(`<< /Type /Page /Parent 0 0 R /MediaBox [0 0 ${PAGE_W.toFixed(2)} ${PAGE_H.toFixed(2)}] /Resources << /Font << /F1 ${fontObjNum} 0 R >> >> /Contents ${contentObjNum} 0 R >>`);
        pageObjs.push(pageObjNum);
      }
  
      const kids = pageObjs.map(n => `${n} 0 R`).join(" ");
      const pagesObjNum = addObj(`<< /Type /Pages /Kids [ ${kids} ] /Count ${pageObjs.length} >>`);
      for(const n of pageObjs){
        objects[n-1] = objects[n-1].replace("/Parent 0 0 R", `/Parent ${pagesObjNum} 0 R`);
      }
      const catalogObjNum = addObj(`<< /Type /Catalog /Pages ${pagesObjNum} 0 R >>`);
  
      let pdf = "%PDF-1.4\n";
      const offsets = [0];
      for(let i=0;i<objects.length;i++){
        offsets.push(pdf.length);
        pdf += `${i+1} 0 obj\n${objects[i]}\nendobj\n`;
      }
      const xrefPos = pdf.length;
      pdf += "xref\n";
      pdf += `0 ${objects.length+1}\n`;
      pdf += "0000000000 65535 f \n";
      for(let i=1;i<offsets.length;i++){
        const off = String(offsets[i]).padStart(10,'0');
        pdf += `${off} 00000 n \n`;
      }
      pdf += "trailer\n";
      pdf += `<< /Size ${objects.length+1} /Root ${catalogObjNum} 0 R >>\n`;
      pdf += "startxref\n";
      pdf += `${xrefPos}\n%%EOF`;
  
      return new Blob([pdf], {type: "application/pdf"});
    }
  
    window.AZExport = {
      formatHours,
      formatNum,
      parseGermanNumber,
      parseCsv,
      buildCsv,
      downloadText,
      downloadBlob,
      createSimplePdf,
      buildMobileHtmlReport
    };
  })();
  
  
  /* ==== app.js ==== */
  /* app.js - main UI/logic */
  (function(){
    'use strict';
  
    const APP_MIN_YEAR = 2025;
  
    const BACKUP_REMINDER_DAYS = 7;
    const KEY_FIRST_RUN_AT = 'firstRunAt';
    const KEY_LAST_BACKUP_AT = 'lastBackupAt';
    const KEY_LAST_BACKUP_PROMPT_AT = 'lastBackupPromptAt';
  
    const els = (id) => document.getElementById(id);
  
    const $dayList = els('dayList');
    const $monthLabel = els('monthLabel');
    const $companyName = els('companyName');
    const $personNameHeader = els('personNameHeader');
  
    const $statSoll = els('statSoll');
    const $statIst = els('statIst');
    const $statCarry = els('statCarry');
    const $statSaldo = els('statSaldo');
    const $statVac = els('statVac');
    const $statSick = els('statSick');
  
    const $settingsModal = els('settingsModal');
    const $importModal = els('importModal');
    const $backupModal = els('backupModal');
    const $backupHint = els('backupHint');
    const $toast = els('toast');
    const $updateBanner = els('updateBanner');
    const $updateText = els('updateText');
    const $appVersion = els('appVersion');
  
    const $yearView = els('yearView');
    const $yearCards = els('yearCards');
    const $yearTitle = els('yearTitle');
    const $yearSummary = els('yearSummary');
  
    // Settings fields
    const $setCompany = els('setCompany');
    const $setPerson = els('setPerson');
    const $setState = els('setState');
    const $setAssumption = els('setAssumption'); // Mari√§ Himmelfahrt
    const $setAugsburg = els('setAugsburg');
    const $setVacationPerYear = els('setVacationPerYear');
    const $setUseYearSummaryMonthly = els('setUseYearSummaryMonthly');
    const $setYearStartSaldo = els('setYearStartSaldo');
    const $holidayPreview = els('holidayPreview');
    const $updateInfo = els('updateInfo');
    const $lastBackupInfo = els('lastBackupInfo');
    const $btnInstallApp = els('btnInstallApp');
    const $installInfo = els('installInfo');
  
    let deferredInstallPrompt = null;
  
    // Import fields
    const $fileImportCsv = els('fileImportCsv');
    const $importMeta = els('importMeta');
    const $importPreview = els('importPreview');
    const $importMode = els('importMode');
  
    // state
    let settings = null;
    let current = { year: null, month: null }; // month 1..12
    let openDateKey = null;
    let pendingImport = null; // {rows, errors, meta}
  
    // ---- Utils ----
    function toast(msg){
      $toast.textContent = msg;
      $toast.classList.remove('hidden');
      clearTimeout(toast._t);
      toast._t = setTimeout(()=> $toast.classList.add('hidden'), 2300);
    }
  
    function pad2(n){ return String(n).padStart(2,'0'); }
    function parseKey(key){
      const y = parseInt(key.slice(0,4),10);
      const m = parseInt(key.slice(5,7),10);
      const d = parseInt(key.slice(8,10),10);
      return {y,m,d};
    }
    function toDateObj(key){
      const {y,m,d} = parseKey(key);
      return new Date(y, m-1, d, 12,0,0);
    }
    function toKey(y,m,d){
      return `${y}-${pad2(m)}-${pad2(d)}`;
    }
    function daysInMonth(y,m){
      return new Date(y, m, 0).getDate();
    }
    const WEEKDAYS = ["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"];
    const MONTHS = ["Januar","Februar","M√§rz","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"];
  
    function weekdayName(key){
      return WEEKDAYS[toDateObj(key).getDay()];
    }
    function isWeekend(key){
      const wd = toDateObj(key).getDay();
      return wd===0 || wd===6;
    }
    function baseSollHours(key){
      return isWeekend(key) ? 0 : 8;
    }
  
    function isoWeekNumber(date){
      // ISO week date algorithm
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
      return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }
  
    function formatHours(h){ return AZExport.formatHours(h); }
  
    function clampYear(y){
      if(y < APP_MIN_YEAR) return APP_MIN_YEAR;
      return y;
    }
  
    function getYearStartSaldoKey(year){ return `yearStartSaldo_${year}`; }
  
    // ---- Settings ----
    async function loadSettings(){
      const company = await AZDB.getSetting('company', 'Zaunteam');
      const person = await AZDB.getSetting('person', '');
      const state = await AZDB.getSetting('state', 'BY');
      const assumption = await AZDB.getSetting('assumption', true); // Mari√§ Himmelfahrt
      const augsburg = await AZDB.getSetting('augsburg', false);
      const vacationPerYear = await AZDB.getSetting('vacationPerYear', 30);
      const useYearSummaryMonthly = await AZDB.getSetting('useYearSummaryMonthly', true);
  
      settings = { company, person, state, assumption: !!assumption, augsburg: !!augsburg, vacationPerYear: parseInt(vacationPerYear,10) || 30, useYearSummaryMonthly: !!useYearSummaryMonthly };
    }
  
    async function saveSettings(){
      settings.company = ($setCompany.value || 'Zaunteam').trim();
      settings.person = ($setPerson.value || '').trim();
      settings.state = $setState.value || 'BY';
      settings.assumption = !!$setAssumption.checked;
      settings.augsburg = !!$setAugsburg.checked;
      settings.vacationPerYear = parseInt($setVacationPerYear.value,10) || 30;
      settings.useYearSummaryMonthly = $setUseYearSummaryMonthly ? !!$setUseYearSummaryMonthly.checked : true;
  
      await AZDB.setSetting('company', settings.company);
      await AZDB.setSetting('person', settings.person);
      await AZDB.setSetting('state', settings.state);
      await AZDB.setSetting('assumption', settings.assumption);
      await AZDB.setSetting('augsburg', settings.augsburg);
      await AZDB.setSetting('vacationPerYear', settings.vacationPerYear);
      await AZDB.setSetting('useYearSummaryMonthly', settings.useYearSummaryMonthly);
  
      // year start saldo (current year)
      const year = current.year;
      const val = Number($setYearStartSaldo.value || 0);
      await AZDB.setSetting(getYearStartSaldoKey(year), Number.isFinite(val) ? val : 0);
  
      $companyName.textContent = settings.company;
      toast("Einstellungen gespeichert");
      closeSettings();
      await renderMonth();
    }
  
    async function getYearStartSaldo(year){
      const v = await AZDB.getSetting(getYearStartSaldoKey(year), 0);
      const num = Number(v);
      return Number.isFinite(num) ? num : 0;
    }
  
    function fillStateSelect(){
      $setState.innerHTML = "";
      for(const [code, name] of AZHolidays.STATES){
        const opt = document.createElement('option');
        opt.value = code;
        opt.textContent = `${name} (${code})`;
        $setState.appendChild(opt);
      }
    }
  
    async function openSettings(){
      // fill fields
      $setCompany.value = settings.company;
      $setPerson.value = settings.person;
      $setState.value = settings.state;
      $setAssumption.checked = settings.assumption;
      $setAugsburg.checked = settings.augsburg;
      $setVacationPerYear.value = settings.vacationPerYear;
      if($setUseYearSummaryMonthly) $setUseYearSummaryMonthly.checked = !!settings.useYearSummaryMonthly;
  
      const ys = await getYearStartSaldo(current.year);
      $setYearStartSaldo.value = ys;
  
      await refreshHolidayPreview();
  
      // last backup info
      try{
        const ts = await AZDB.getSetting(KEY_LAST_BACKUP_AT, 0) || 0;
        if($lastBackupInfo){
          if(!ts){
            $lastBackupInfo.textContent = "‚Äî (noch kein Backup)";
          }else{
            const d = new Date(ts);
            $lastBackupInfo.textContent = d.toLocaleString('de-DE', {year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'});
          }
        }
      }catch(_e){ if($lastBackupInfo) $lastBackupInfo.textContent = "‚Äî"; }
  
      $settingsModal.classList.remove('hidden');
    }
    function closeSettings(){ $settingsModal.classList.add('hidden'); }
  
    async function refreshHolidayPreview(){
      const year = current.year;
      const state = $setState.value || settings.state;
      const opts = { assumption: $setAssumption.checked, augsburg: $setAugsburg.checked };
      const map = AZHolidays.holidaysForYear(year, state, opts);
      const items = Array.from(map.entries()).sort((a,b)=>a[0].localeCompare(b[0]));
      const lines = items.map(([k,v])=>{
        const d = toDateObj(k);
        const dd = pad2(d.getDate());
        const mm = pad2(d.getMonth()+1);
        return `${dd}.${mm}.${d.getFullYear()}  ‚Äì  ${v}`;
      });
      $holidayPreview.textContent = lines.join("\n") || "‚Äî";
    }
  
    // ---- Day model helpers ----
    function getDefaultType(key){
      // weekend rest, otherwise holiday if in holiday map, else work
      if(isWeekend(key)) return 'rest';
      const name = AZHolidays.getHolidayName(key, settings.state, {assumption: settings.assumption, augsburg: settings.augsburg});
      if(name) return 'holiday';
      return 'work';
    }
  
    function getHolidayNameIfAny(key){
      return AZHolidays.getHolidayName(key, settings.state, {assumption: settings.assumption, augsburg: settings.augsburg});
    }
  
    function normalizeRecord(key, rec){
      const defType = getDefaultType(key);
      const out = {
        date: key,
        type: defType,
        start: "",
        end: "",
        breakH: 0.5,
        place: "",
        note: ""
      };
      if(rec){
        out.type = rec.type || defType;
        out.start = rec.start || "";
        out.end = rec.end || "";
        out.breakH = (rec.breakH != null ? Number(rec.breakH) : 0.5);
        if(!Number.isFinite(out.breakH)) out.breakH = 0.5;
        out.place = rec.place || "";
        out.note = rec.note || "";
      }
      // if non-work types, pause should be 0
      if(out.type !== 'work') out.breakH = 0;
      return out;
    }
  
    function calcNetHours(start, end, breakH){
      if(!start || !end) return 0;
      const m1 = start.split(':'); const m2 = end.split(':');
      if(m1.length<2 || m2.length<2) return 0;
      let s = parseInt(m1[0],10)*60 + parseInt(m1[1],10);
      let e = parseInt(m2[0],10)*60 + parseInt(m2[1],10);
      if(!Number.isFinite(s) || !Number.isFinite(e)) return 0;
      if(e < s) e += 24*60; // over midnight
      let netMin = e - s - Math.round((breakH||0)*60);
      if(netMin < 0) netMin = 0;
      return netMin/60;
    }
  
    function calcDayHours(key, recNorm){
      const soll = baseSollHours(key);
      let ist = 0;
      if(recNorm.type === 'work'){
        ist = calcNetHours(recNorm.start, recNorm.end, recNorm.breakH);
        return {soll, ist, diff: ist - soll};
      }
      if(recNorm.type === 'rest'){
        return {soll:0, ist:0, diff:0};
      }
      // vacation/sick/holiday/comp -> counts as soll on weekdays, else 0
      return {soll, ist: soll, diff: 0};
    }
  
    // ---- Month render ----
    async function renderMonth(){
      $yearView.classList.add('hidden');
      $dayList.classList.remove('hidden');
      // clamp year
      current.year = clampYear(current.year);
      if(current.year === APP_MIN_YEAR && current.month === 0) current.month = 1;
  
      $monthLabel.textContent = `${MONTHS[current.month-1]} ${current.year}`;
  
      const dayKeys = [];
      const dim = daysInMonth(current.year, current.month);
      for(let d=1; d<=dim; d++){
        dayKeys.push(toKey(current.year, current.month, d));
      }
  
      // load stored records for this month
      const startKey = dayKeys[0];
      const endKey = dayKeys[dayKeys.length-1];
      const stored = await AZDB.getRange(startKey, endKey);
      const map = new Map(stored.map(r=>[r.date, r]));
  
      // compute carry within year
      let startSaldo = await calcCarryToMonth(current.year, current.month);
  
      // Wenn Monats-/Jahres-CSV Werte vorhanden sind (Okt/Nov), soll der "S. Vormonat"
      // auch im Dezember (mit Tagesdaten) auf dieser Basis weiterlaufen ‚Äì sonst entstehen
      // riesige Negativsalden durch angenommene leere Monate.
      if(settings.useYearSummaryMonthly){
        const ysCarry = await getYearSummary(current.year);
        if(hasImportedCarryBaseline(ysCarry, current.month)){
          startSaldo = deriveImportedCarry(ysCarry, current.month);
        }
      }
      let sumSoll=0, sumIst=0, sumDiff=0;
  
      // build list (alle Tage + Inline-Editor im Listeneintrag)
      $dayList.innerHTML = "";
  
      // openDateKey nur behalten, wenn er im aktuellen Monat liegt
      if(openDateKey && !openDateKey.startsWith(`${current.year}-${pad2(current.month)}-`)) openDateKey = null;
  
      for(const key of dayKeys){
        const recNorm = normalizeRecord(key, map.get(key));
        const hours = calcDayHours(key, recNorm);
        sumSoll += hours.soll;
        sumIst += hours.ist;
        sumDiff += hours.diff;
  
        const d = toDateObj(key);
        const wname = WEEKDAYS[d.getDay()];
        const dd = pad2(d.getDate());
        const dateLabel = `${wname}, ${dd}. ${MONTHS[d.getMonth()]} ${d.getFullYear()}`;
  
        const card = document.createElement('div');
        card.className = 'day-card';
        card.dataset.date = key;
  
        const summary = document.createElement('div');
        summary.className = 'day-item';
        summary.dataset.date = key;
  
        const left = document.createElement('div');
        left.className = 'day-left';
  
        const line1 = document.createElement('div');
        line1.className = 'd1';
        line1.textContent = dateLabel;
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = typeLabel(recNorm.type, key);
        line1.appendChild(badge);
  
        const line2 = document.createElement('div');
        line2.className = 'd2';
        if(recNorm.type === 'work'){
          if(recNorm.start && recNorm.end) line2.textContent = `${recNorm.start} - ${recNorm.end}`;
          else line2.textContent = '‚Äî';
        }else if(recNorm.type === 'rest'){
          line2.textContent = 'Ruhetag';
        }else{
          const hn = recNorm.type === 'holiday' ? getHolidayNameIfAny(key) : null;
          line2.textContent = hn ? hn : typeLabel(recNorm.type, key);
        }
  
        const line3 = document.createElement('div');
        line3.className = 'd3';
        if(recNorm.type === 'work'){
          const p = (recNorm.breakH ?? 0.5);
          line3.textContent = `${p.toFixed(2).replace('.',',')} h Essens-/Pausenzeiten`;
        }
  
        left.appendChild(line1);
        left.appendChild(line2);
        if(line3.textContent) left.appendChild(line3);
  
        const right = document.createElement('div');
        right.className = 'day-right';
        const big = document.createElement('div');
        big.className = 'hbig';
        big.textContent = `${hours.ist.toFixed(2).replace('.',',')} h`;
        const diff = document.createElement('div');
        diff.className = 'hdiff';
        diff.textContent = `(${hours.diff.toFixed(2).replace('.',',')})`;
        if(hours.diff > 0.005) diff.classList.add('good');
        else if(hours.diff < -0.005) diff.classList.add('bad');
        right.appendChild(big);
        right.appendChild(diff);
  
        summary.appendChild(left);
        summary.appendChild(right);
  
        const editor = document.createElement('div');
        editor.className = 'day-editor-inline';
        if(openDateKey !== key) editor.classList.add('hidden');
        editor.innerHTML = `
          <div class="inline-head">
            <div class="inline-meta">${wname} ${dd}.${pad2(d.getMonth()+1)}.${d.getFullYear()} ‚Ä¢ Woche ${isoWeekNumber(d)}<\/div>
          <\/div>
          <div class="inline-grid">
            <div class="inline-row">
              <label>Typ<\/label>
              <select class="in-type">
                <option value="work">Arbeitszeit<\/option>
                <option value="vac">Urlaub<\/option>
                <option value="sick">Krank<\/option>
                <option value="holiday">Feiertag<\/option>
                <option value="comp">Zeitausgleich<\/option>
                <option value="rest">Ruhetag<\/option>
              <\/select>
            <\/div>
            <div class="inline-row times">
              <label>Start<\/label>
              <input type="time" class="in-start" />
              <div class="mid">bis<\/div>
              <input type="time" class="in-end" />
            <\/div>
            <div class="inline-row">
              <label>Pause (h)<\/label>
              <input type="number" step="0.25" min="0" class="in-break" />
            <\/div>
            <div class="inline-row">
              <label>Ort<\/label>
              <input type="text" class="in-place" placeholder="Baustelle / Ort" />
            <\/div>
            <div class="inline-row">
              <label>Notiz<\/label>
              <textarea rows="2" class="in-note" placeholder="Bemerkung zum Tag‚Ä¶"><\/textarea>
            <\/div>
            <div class="inline-hint">Tipp: Nicht-Arbeitszeit z√§hlt automatisch als 8,00 h (Mo‚ÄìFr).<\/div>
          <\/div>
          <div class="inline-actions">
            <button class="btn btn-light in-copy" type="button">Wie gestern<\/button>
            <div class="spacer"><\/div>
            <button class="btn btn-light in-close" type="button">Schlie√üen<\/button>
            <button class="btn btn-primary in-save" type="button">Speichern<\/button>
          <\/div>
        `;
  
        const refs = {
          type: editor.querySelector('.in-type'),
          start: editor.querySelector('.in-start'),
          end: editor.querySelector('.in-end'),
          breakH: editor.querySelector('.in-break'),
          place: editor.querySelector('.in-place'),
          note: editor.querySelector('.in-note')
        };
  
        // init input values
        refs.type.value = recNorm.type;
        refs.start.value = recNorm.start || '';
        refs.end.value = recNorm.end || '';
        refs.breakH.value = String(recNorm.type === 'work' ? (recNorm.breakH ?? 0.5) : 0);
        refs.place.value = recNorm.place || '';
        refs.note.value = recNorm.note || '';
        applyTypeRulesToInputs(refs.type.value, refs.start, refs.end, refs.breakH);
  
        refs.type.addEventListener('change', ()=>{
          applyTypeRulesToInputs(refs.type.value, refs.start, refs.end, refs.breakH);
        });
  
        editor.querySelector('.in-copy').addEventListener('click', async (ev)=>{
          ev.stopPropagation();
          await copyYesterdayInto(key, refs);
          applyTypeRulesToInputs(refs.type.value, refs.start, refs.end, refs.breakH);
        });
  
        editor.querySelector('.in-close').addEventListener('click', (ev)=>{
          ev.stopPropagation();
          openDateKey = null;
          card.classList.remove('open');
          editor.classList.add('hidden');
        });
  
        editor.querySelector('.in-save').addEventListener('click', async (ev)=>{
          ev.stopPropagation();
          await saveInlineDay(key, refs);
          toast('Gespeichert');
          openDateKey = null;
          await renderMonth();
          // nach dem Speichern wieder zum Tag scrollen
          setTimeout(()=>scrollToDay(key), 40);
        });
  
        summary.addEventListener('click', async ()=>{
          const isOpen = card.classList.contains('open');
          // close any open card
          const open = $dayList.querySelector('.day-card.open');
          if(open && open !== card){
            open.classList.remove('open');
            const _edi = open.querySelector('.day-editor-inline');
            if(_edi) _edi.classList.add('hidden');
          }
          if(isOpen){
            card.classList.remove('open');
            editor.classList.add('hidden');
            openDateKey = null;
          }else{
            // reload record when opening (in case it changed)
            const fresh = await AZDB.getDay(key);
            await fillInlineInputs(key, fresh, refs);
            card.classList.add('open');
            editor.classList.remove('hidden');
            openDateKey = key;
            setTimeout(()=>editor.scrollIntoView({block:'nearest', behavior:'smooth'}), 0);
          }
        });
  
        card.appendChild(summary);
        card.appendChild(editor);
        if(openDateKey === key){
          card.classList.add('open');
          editor.classList.remove('hidden');
        }
        $dayList.appendChild(card);
      }
  
      // update month stats (optional: aus importierter Jahres-CSV √ºbernehmen)
      let saldo = startSaldo + sumDiff;
  
      // IMPORTANT: Wenn es Tagesdaten f√ºr diesen Monat gibt, muss die Berechnung tagesaktuell
      // aus den Eintr√§gen erfolgen. Jahres-/Monats-CSV Werte dienen nur als Fallback,
      // wenn in diesem Monat noch keine Tagesdaten vorhanden sind.
      if(settings.useYearSummaryMonthly && stored.length === 0){
        const ys = await getYearSummary(current.year);
        const im = findImportedMonth(ys, current.month);
        if(im){
          const iSoll = Number(im.soll||0);
          const iIst  = Number(im.ist||0);
          const iDiff = (im.diff!=null) ? Number(im.diff||0) : (iIst - iSoll);
          const iSaldo = (im.saldo!=null) ? Number(im.saldo||0) : (deriveImportedCarry(ys, current.month) + iDiff);
          const iCarry = deriveImportedCarry(ys, current.month);
  
          sumSoll = iSoll; sumIst = iIst; sumDiff = iDiff;
          startSaldo = iCarry; saldo = iSaldo;
        }
      }
  
      $statSoll.textContent = formatHours(sumSoll);
      $statIst.textContent = formatHours(sumIst);
      $statCarry.textContent = formatHours(startSaldo);
      $statSaldo.textContent = formatHours(saldo);
      setGoodBad($statCarry, startSaldo);
      setGoodBad($statSaldo, saldo);
  
      // company + person
      $companyName.textContent = settings.company;
      $personNameHeader.textContent = (settings.person || '');
  
      // Urlaub/Krank (Jahr)
      const yc = await calcYearCounters(current.year);
      $statVac.textContent = yc.vacUsed + '/' + settings.vacationPerYear;
      $statSick.textContent = yc.sickDays + ' Tg';
    }
  
    function setGoodBad(el, v){
      el.classList.remove('good','bad');
      if(v > 0.005) el.classList.add('good');
      else if(v < -0.005) el.classList.add('bad');
    }
  
    function typeLabel(type, key){
      switch(type){
        case 'work': return 'Arbeitszeit';
        case 'vac': return 'Urlaub';
        case 'sick': return 'Krank';
        case 'holiday': return 'Feiertag';
        case 'rest': return 'Ruhetag';
        case 'comp': return 'Zeitausgleich';
        default: return getDefaultType(key);
      }
    }
  
    
    // ---- Jahres-CSV Monatswerte (Override) ----
    const MONTH_NAME_MAP = {
      'januar':1,'jan':1,
      'februar':2,'feb':2,
      'm√§rz':3,'maerz':3,'mrz':3,'mar':3,
      'april':4,'apr':4,
      'mai':5,
      'juni':6,'jun':6,
      'juli':7,'jul':7,
      'august':8,'aug':8,
      'september':9,'sep':9,'sept':9,
      'oktober':10,'okt':10,'oct':10,
      'november':11,'nov':11,
      'dezember':12,'dez':12,'dec':12
    };
  
    function monthIndexFromAny(m){
      if(!m) return null;
      if(typeof m.month === 'number' && m.month>=1 && m.month<=12) return m.month;
      if(typeof m.month === 'string'){
        const s = m.month.trim().toLowerCase();
        if(MONTH_NAME_MAP[s]) return MONTH_NAME_MAP[s];
        const n = parseInt(s,10);
        if(Number.isFinite(n) && n>=1 && n<=12) return n;
      }
      if(typeof m.name === 'string'){
        const s = m.name.trim().toLowerCase();
        if(MONTH_NAME_MAP[s]) return MONTH_NAME_MAP[s];
        const s2 = s.replace('√§','ae').replace('√∂','oe').replace('√º','ue');
        if(MONTH_NAME_MAP[s2]) return MONTH_NAME_MAP[s2];
      }
      return null;
    }
  
    async function getYearSummary(year){
      const raw = await AZDB.getSetting('yearSummary_' + year, null);
      if(!raw) return null;
      try{ return JSON.parse(raw); }catch(e){ return null; }
    }
  
    // ---- Data presence helpers (verhindert riesige negative Salden f√ºr Monate ohne echte Eintr√§ge) ----
    const _firstDataMonthCache = new Map();
    function invalidateYearCache(year){
      _firstDataMonthCache.delete(Number(year));
    }
  
    async function getFirstDataMonth(year){
      const y = Number(year);
      if(_firstDataMonthCache.has(y)) return _firstDataMonthCache.get(y);
      const start = toKey(y, 1, 1);
      const end = toKey(y, 12, 31);
      const all = await AZDB.getRange(start, end);
      let minMonth = null;
      for(const r of all){
        if(!r || !r.date) continue;
        const mm = parseInt(String(r.date).slice(5,7), 10);
        if(Number.isFinite(mm) && mm >= 1 && mm <= 12){
          if(minMonth == null || mm < minMonth) minMonth = mm;
        }
      }
      _firstDataMonthCache.set(y, minMonth);
      return minMonth;
    }
  
    function findImportedMonth(ys, month){
      if(!ys || !Array.isArray(ys.months)) return null;
      // try by numeric month
      for(const m of ys.months){
        const mi = monthIndexFromAny(m);
        if(mi === month) return m;
      }
      // fallback: if array is 12 items in order
      if(ys.months.length >= month) return ys.months[month-1];
      return null;
    }
  
    function deriveImportedCarry(ys, month){
      if(!ys || !Array.isArray(ys.months)) return 0;
      const m = findImportedMonth(ys, month);
      if(m && typeof m.carry === 'number') return m.carry;
      // in CSV: Jan carry = yearStartSaldo, others carry = previous month saldo
      if(month === 1) return Number(ys.yearStartSaldo || 0) || 0;
      const prev = findImportedMonth(ys, month-1);
      if(prev && prev.saldo != null) return Number(prev.saldo || 0) || 0;
      return 0;
    }
  
    function hasImportedCarryBaseline(ys, month){
      if(!ys || !Array.isArray(ys.months)) return false;
      const m = findImportedMonth(ys, month);
      if(m && typeof m.carry === 'number') return true;
      if(month === 1 && ys.yearStartSaldo != null) return true;
      if(month > 1){
        const prev = findImportedMonth(ys, month-1);
        if(prev && prev.saldo != null) return true;
      }
      return false;
    }
  
  
    async function calcCarryToMonth(year, month){
      const startSaldoYear = await getYearStartSaldo(year);
      if(month <= 1) return startSaldoYear;
  
      // Nur ab dem ersten Monat mit echten Tagesdaten rechnen.
      // Dadurch werden Monate, die nie erfasst wurden (z.B. Jan‚ÄìSep), NICHT als -8h/Tag gewertet.
      const firstM = await getFirstDataMonth(year);
      if(!firstM || firstM >= month) return startSaldoYear;
  
      let carry = startSaldoYear;
      for(let m=firstM; m<month; m++){
        const {diff} = await calcMonthDiff(year, m, { ignoreEmpty: true });
        carry += diff;
      }
      return carry;
    }
  
    async function calcMonthDiff(year, month, opts){
      const dim = daysInMonth(year, month);
      const startKey = toKey(year, month, 1);
      const endKey = toKey(year, month, dim);
      const stored = await AZDB.getRange(startKey, endKey);
      if(opts && opts.ignoreEmpty && stored.length === 0){
        return {soll:0, ist:0, diff:0, empty:true};
      }
      const map = new Map(stored.map(r=>[r.date, r]));
      let diff=0, soll=0, ist=0;
      for(let d=1; d<=dim; d++){
        const key = toKey(year, month, d);
        const rec = normalizeRecord(key, map.get(key));
        const h = calcDayHours(key, rec);
        soll += h.soll; ist += h.ist; diff += h.diff;
      }
      return {soll, ist, diff};
    }
  
    async function calcYearToMonth(year, month){
      const m = Math.max(1, Math.min(12, Number(month)||1));
      let soll=0, ist=0, diff=0;
      const firstM = await getFirstDataMonth(year);
      const startM = firstM ? Math.max(1, Math.min(12, firstM)) : 1;
      for(let mm=startM; mm<=m; mm++){
        const r = await calcMonthDiff(year, mm, { ignoreEmpty: true });
        soll += r.soll; ist += r.ist; diff += r.diff;
      }
      return {soll, ist, diff};
    }
  
    async function calcYearCounters(year){
      const start = toKey(year, 1, 1);
      const end = toKey(year, 12, 31);
      const all = await AZDB.getRange(start, end);
      let vacUsed = 0;
      let sickDays = 0;
      for(const r of all){
        if(!r || !r.date) continue;
        if(r.type === 'vac' && baseSollHours(r.date) > 0) vacUsed++;
        if(r.type === 'sick' && baseSollHours(r.date) > 0) sickDays++;
      }
  
      // Fallback: wenn noch keine Tagesdaten vorhanden sind, nutze ggf. Jahres-CSV-Import
      if(all.length === 0){
        const raw = await AZDB.getSetting('yearSummary_' + year, null);
        if(raw){
          try{
            const ys = JSON.parse(raw);
            const total = ys && ys.counts && ys.counts.totalByKey ? ys.counts.totalByKey : null;
            if(total){
              if(typeof total.ferien_urlaub === 'number') vacUsed = total.ferien_urlaub;
              if(typeof total.krank === 'number') sickDays = total.krank;
            }
          }catch(e){ /* ignore */ }
        }
      }
  
      return {vacUsed, sickDays};
    }
  
    // ---- Inline Editor (im Listen-Eintrag) ----
    function applyTypeRulesToInputs(type, startEl, endEl, breakEl){
      const work = (type === 'work');
      startEl.disabled = !work;
      endEl.disabled = !work;
      breakEl.disabled = !work;
      if(work){
        if(!breakEl.value) breakEl.value = '0.5';
      }else{
        startEl.value = '';
        endEl.value = '';
        breakEl.value = '0';
      }
    }
  
    async function fillInlineInputs(key, rec, refs){
      const norm = normalizeRecord(key, rec);
      refs.type.value = norm.type;
      refs.start.value = norm.start || '';
      refs.end.value = norm.end || '';
      refs.breakH.value = String(norm.type === 'work' ? (norm.breakH ?? 0.5) : 0);
      refs.place.value = norm.place || '';
      refs.note.value = norm.note || '';
      applyTypeRulesToInputs(norm.type, refs.start, refs.end, refs.breakH);
    }
  
    async function copyYesterdayInto(key, refs){
      const d = toDateObj(key);
      d.setDate(d.getDate()-1);
      const yKey = toKey(d.getFullYear(), d.getMonth()+1, d.getDate());
      const prev = await AZDB.getDay(yKey);
      const normPrev = normalizeRecord(yKey, prev);
      refs.start.value = normPrev.start || '';
      refs.end.value = normPrev.end || '';
      refs.breakH.value = String(normPrev.breakH ?? 0.5);
      if(normPrev.place) refs.place.value = normPrev.place;
      toast('Wie gestern √ºbernommen');
    }
  
    async function saveInlineDay(key, refs){
      const t = refs.type.value || getDefaultType(key);
      const rec = {
        date: key,
        type: t,
        start: (refs.start.value || '').trim(),
        end: (refs.end.value || '').trim(),
        breakH: Number(refs.breakH.value || 0),
        place: (refs.place.value || '').trim(),
        note: (refs.note.value || '').trim(),
        updatedAt: Date.now()
      };
      if(!Number.isFinite(rec.breakH) || rec.breakH < 0) rec.breakH = 0;
      if(t !== 'work'){ rec.start=''; rec.end=''; rec.breakH = 0; }
      await AZDB.setDay(rec);
      // Cache f√ºr ersten Daten-Monat invalidieren (wichtig)
      try{ invalidateYearCache(parseInt(String(key).slice(0,4),10)); }catch(e){ /* ignore */ }
    }
  
  
    // ---- Year view ----
    async function openYearView(){
      $dayList.classList.add('hidden');
      $yearView.classList.remove('hidden');
  
      const year = current.year;
      $yearTitle.textContent = `Jahr ${year}`;
      $yearCards.innerHTML = "";
  
      let ySoll=0, yIst=0, yDiff=0;
  
      for(let m=1; m<=12; m++){
        // Wenn vorhanden: Monatswerte aus importierter Jahres-CSV benutzen
        if(settings.useYearSummaryMonthly){
          const ysImp = await getYearSummary(year);
          const im = findImportedMonth(ysImp, m);
          if(im){
            const carry = deriveImportedCarry(ysImp, m);
            const soll = Number(im.soll||0);
            const ist  = Number(im.ist||0);
            const diff = (im.diff!=null)?Number(im.diff||0):(ist-soll);
            const saldo = (im.saldo!=null)?Number(im.saldo||0):(carry+diff);
            // render card using imported values
            const card = document.createElement('div');
            card.className = 'year-card';
            card.innerHTML = `
          <div>
            <div class="mname">${MONTHS[m-1]}</div>
            <div class="small">S. Vormonat: ${AZExport.formatNum(carry)} h</div>
          </div>
          <div class="vals">
            <div>Soll: <b>${AZExport.formatNum(soll)} h</b></div>
            <div>Ist: <b>${AZExport.formatNum(ist)} h</b></div>
            <div>Diff: <b class="${diff>0.005?'good':diff<-0.005?'bad':''}">${AZExport.formatNum(diff)} h</b></div>
            <div>Saldo: <b class="${saldo>0.005?'good':saldo<-0.005?'bad':''}">${AZExport.formatNum(saldo)} h</b></div>
          </div>
        `;
            card.addEventListener('click', ()=>{
              current.month = m;
              openDateKey = null;
              renderMonth();
            });
            $yearCards.appendChild(card);
            continue;
          }
        }
  
        const {soll, ist, diff} = await calcMonthDiff(year, m, { ignoreEmpty: true });
        ySoll += soll; yIst += ist; yDiff += diff;
  
        const carry = await calcCarryToMonth(year, m);
        const saldo = carry + diff;
  
        const card = document.createElement('div');
        card.className = 'year-card';
        card.innerHTML = `
          <div>
            <div class="mname">${MONTHS[m-1]}<\/div>
            <div class="small">S. Vormonat: ${AZExport.formatNum(carry)} h<\/div>
          <\/div>
          <div class="vals">
            <div>Soll: <b>${AZExport.formatNum(soll)} h<\/b><\/div>
            <div>Ist: <b>${AZExport.formatNum(ist)} h<\/b><\/div>
            <div>Diff: <b class="${diff>0.005?'good':diff<-0.005?'bad':''}">${AZExport.formatNum(diff)} h<\/b><\/div>
            <div>Saldo: <b class="${saldo>0.005?'good':saldo<-0.005?'bad':''}">${AZExport.formatNum(saldo)} h<\/b><\/div>
          <\/div>
        `;
        card.addEventListener('click', ()=>{
          current.month = m;
          openDateKey = null;
          renderMonth();
        });
        $yearCards.appendChild(card);
      }
  
      const yc = await calcYearCounters(year);
      const vacLeft = Math.max(0, settings.vacationPerYear - yc.vacUsed);
      const startSaldo = await getYearStartSaldo(year);
      const ySaldo = startSaldo + yDiff;
  
      // Optional: Importierte Jahres-CSV anzeigen
      let importBox = '';
      const raw = await AZDB.getSetting('yearSummary_' + year, null);
      if(raw){
        try{
          const ys = JSON.parse(raw);
          importBox = buildImportedYearBox(ys);
        }catch(e){ /* ignore */ }
      }
  
      $yearSummary.innerHTML = `
        <div><b>Jahres-Soll:<\/b> ${AZExport.formatNum(ySoll)} h<\/div>
        <div><b>Jahres-Ist:<\/b> ${AZExport.formatNum(yIst)} h<\/div>
        <div><b>Jahres-Diff:<\/b> <span class="${yDiff>0.005?'good':yDiff<-0.005?'bad':''}"><b>${AZExport.formatNum(yDiff)} h<\/b><\/span><\/div>
        <div><b>Startsaldo Jahr:<\/b> ${AZExport.formatNum(startSaldo)} h<\/div>
        <div><b>Jahres-Saldo:<\/b> <span class="${ySaldo>0.005?'good':ySaldo<-0.005?'bad':''}"><b>${AZExport.formatNum(ySaldo)} h<\/b><\/span><\/div>
        <hr />
        <div><b>Urlaub:<\/b> ${yc.vacUsed} genommen / ${vacLeft} √ºbrig (von ${settings.vacationPerYear})<\/div>
        <div><b>Krank:<\/b> ${yc.sickDays} Tage<\/div>
        ${importBox}
      `;
    }
  
    function escHtml(s){
      return String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }
  
    function buildImportedYearBox(ys){
      if(!ys || (!ys.months && !ys.counts)) return '';
  
      let html = `<div class="import-box"><div class="import-title"><b>CSV Jahres√ºbersicht (Import)<\/b><\/div>`;
  
      if(Array.isArray(ys.months) && ys.months.length){
        html += `<div class="small">Monatswerte aus der Jahres-CSV (Soll/Ist/Diff/Saldo).<\/div>`;
        html += `<div class="table-wrap"><table class="tbl"><thead><tr><th>Monat<\/th><th>Soll<\/th><th>Ist<\/th><th>Diff<\/th><th>Saldo<\/th><\/tr><\/thead><tbody>`;
        for(const m of ys.months){
          if(!m) continue;
          const name = m.name || (typeof m.month==='number'?MONTHS[m.month-1]:String(m.month||''));
          const soll = AZExport.formatNum(Number(m.soll||0));
          const ist  = AZExport.formatNum(Number(m.ist||0));
          const diff = Number(m.diff||0);
          const saldo = Number(m.saldo||0);
          html += `<tr><td>${escHtml(name)}<\/td><td>${soll}<\/td><td>${ist}<\/td><td class="${diff>0.005?'good':diff<-0.005?'bad':''}">${AZExport.formatNum(diff)}<\/td><td class="${saldo>0.005?'good':saldo<-0.005?'bad':''}">${AZExport.formatNum(saldo)}<\/td><\/tr>`;
        }
        html += `</tbody></table></div>`;
      }
  
      if(ys.counts && ys.counts.totalRaw){
        html += `<hr /><div><b>Tage-Statistik (Total)<\/b><\/div>`;
        html += `<div class="chips">`;
        const entries = Object.entries(ys.counts.totalRaw);
        for(const [k,v] of entries){
          html += `<div class="chip"><span>${escHtml(k)}<\/span><b>${escHtml(v)}<\/b><\/div>`;
        }
        html += `</div>`;
  
        // pro Monat (vollst√§ndige Tabelle, horizontal scrollbar)
        if(Array.isArray(ys.counts.months) && ys.counts.months.length && Array.isArray(ys.counts.headers)){
          html += `<div class="small" style="margin-top:8px">Tage-Statistik pro Monat (aus Jahres-CSV).</div>`;
          html += `<div class="table-wrap"><table class="tbl"><thead><tr>`;
          for(const h of ys.counts.headers){
            html += `<th>${escHtml(h)}</th>`;
          }
          html += `</tr></thead><tbody>`;
          for(const row of ys.counts.months){
            html += `<tr>`;
            for(const h of ys.counts.headers){
              const v = row && row.valuesRaw ? (row.valuesRaw[h] ?? '') : '';
              html += `<td>${escHtml(v)}</td>`;
            }
            html += `</tr>`;
          }
          if(ys.counts.totalRaw){
            html += `<tr>`;
            for(const h of ys.counts.headers){
              const v = ys.counts.totalRaw[h] ?? '';
              html += `<td><b>${escHtml(v)}</b></td>`;
            }
            html += `</tr>`;
          }
          html += `</tbody></table></div>`;
        }
      }
  
      html += `</div>`;
      return html;
    }
  
    // ---- Export helpers ----
  
    function buildRowsForRange(startKey, endKey){
      // returns Promise rows with computed soll/ist/diff for each day in range
      return (async ()=>{
        const stored = await AZDB.getRange(startKey, endKey);
        const map = new Map(stored.map(r=>[r.date, r]));
        const rows = [];
        let cur = startKey;
        while(cur <= endKey){
          const d = toDateObj(cur);
          const key = toKey(d.getFullYear(), d.getMonth()+1, d.getDate());
          const rec = normalizeRecord(key, map.get(key));
          const h = calcDayHours(key, rec);
          rows.push({
            datum: `${pad2(d.getDate())}.${pad2(d.getMonth()+1)}.${d.getFullYear()}`,
            wochentag: WEEKDAYS[d.getDay()],
            typ: typeLabel(rec.type, key),
            start: rec.start||"",
            ende: rec.end||"",
            // Pause nur bei echter Arbeitszeit exportieren
            pause_h: (rec.type==='work') ? AZExport.formatNum((rec.breakH ?? 0.5)) : "",
            soll_h: AZExport.formatNum(h.soll),
            ist_h: AZExport.formatNum(h.ist),
            diff_h: AZExport.formatNum(h.diff),
            ort: rec.place||"",
            notiz: rec.note||""
          });
          // increment day
          d.setDate(d.getDate()+1);
          cur = toKey(d.getFullYear(), d.getMonth()+1, d.getDate());
        }
        return rows;
      })();
    }
  
    function todayGerman(){
      const d = new Date();
      return `${pad2(d.getDate())}.${pad2(d.getMonth()+1)}.${d.getFullYear()}`;
    }
  
    function germanDateFromTs(ts){
      try{
        const d = new Date(ts);
        if(!Number.isFinite(d.getTime())) return '‚Äî';
        return `${pad2(d.getDate())}.${pad2(d.getMonth()+1)}.${d.getFullYear()}`;
      }catch(_){ return '‚Äî'; }
    }
  
    async function maybeBackupReminder(){
      try{
        const now = Date.now();
        let firstRun = await AZDB.getSetting(KEY_FIRST_RUN_AT, null);
        if(!firstRun){
          await AZDB.setSetting(KEY_FIRST_RUN_AT, now);
          firstRun = now;
        }
        const lastBackup = await AZDB.getSetting(KEY_LAST_BACKUP_AT, 0) || 0;
        const lastPrompt = await AZDB.getSetting(KEY_LAST_BACKUP_PROMPT_AT, 0) || 0;
  
        const base = lastBackup > 0 ? lastBackup : firstRun;
        const msDay = 86400000;
        const daysSince = Math.floor((now - base) / msDay);
        const daysSincePrompt = Math.floor((now - lastPrompt) / msDay);
  
        if(daysSince >= BACKUP_REMINDER_DAYS && daysSincePrompt >= BACKUP_REMINDER_DAYS){
          const info = lastBackup > 0
            ? `Letztes Backup: ${germanDateFromTs(lastBackup)}. Bitte sicherheitshalber ein neues Backup speichern.`
            : `Noch kein Backup gespeichert. Bitte einmal ein Backup sichern (JSON).`;
          openBackupModal(info);
          await AZDB.setSetting(KEY_LAST_BACKUP_PROMPT_AT, now);
        }
      }catch(e){
        // never block startup
        console.warn('backup reminder failed', e);
      }
    }
  
    function buildExportMetaLines(exportLabel){
      // Meta-Header f√ºr CSV/PDF (wird beim Import automatisch ignoriert)
      const lines = [];
      lines.push('## Arbeitszeiterfassung Export');
      lines.push(`## Firma: ${settings.company || ''}`);
      lines.push(`## Name: ${settings.person || ''}`);
      lines.push(`## Export-Datum: ${todayGerman()}`);
      lines.push(`## Export-Typ: ${exportLabel}`);
      return lines;
    }
  
    async function exportCsvMonth(){
      const y = current.year, m = current.month;
      const startKey = toKey(y,m,1);
      const endKey = toKey(y,m,daysInMonth(y,m));
      const rows = await buildRowsForRange(startKey, endKey);
      const exportLabel = `Monat ${MONTHS[m-1]} ${y}`;
      const meta = buildExportMetaLines(exportLabel).join('\n');
      const csv = meta + "\n" + AZExport.buildCsv(rows);
      AZExport.downloadText(csv, `${settings.person||'Arbeitszeit'}_${settings.company||'Firma'}_Monat_${y}-${pad2(m)}.csv`, 'text/csv;charset=utf-8');
      toast("CSV Monat exportiert");
    }
  
  /* === PATCHPOINT: EXPORT_HANDY_MONTH === */
  async function exportHandyMonth(){
    const y = current.year, m = current.month;
    const startKey = toKey(y,m,1);
    const endKey = toKey(y,m,daysInMonth(y,m));
    const rows = await buildRowsForRange(startKey, endKey);
    const exportLabel = `Monat ${MONTHS[m-1]} ${y}`;
    const title = `Arbeitszeiterfassung`;
    const subtitle = `${settings.company || 'Firma'} ‚Ä¢ ${settings.person || ''} ‚Ä¢ Export: ${todayGerman()}`.replace(/\s+‚Ä¢\s+‚Ä¢/g,' ‚Ä¢').trim();
    const metaLines = buildExportMetaLines(exportLabel);
    const html = AZExport.buildMobileHtmlReport({ title, subtitle, exportLabel, metaLines, rows });
    AZExport.downloadText(html, `${settings.person||'Arbeitszeit'}_${settings.company||'Firma'}_Monat_${y}-${pad2(m)}.html`, 'text/html;charset=utf-8');
    toast("Handy-Report Monat exportiert");
  }
  
    async function exportCsvYear(){
      const y = current.year;
      const startKey = toKey(y,1,1);
      const endKey = toKey(y,12,31);
      const rows = await buildRowsForRange(startKey, endKey);
      const exportLabel = `Jahr ${y}`;
      const meta = buildExportMetaLines(exportLabel).join('\n');
      const csv = meta + "\n" + AZExport.buildCsv(rows);
      AZExport.downloadText(csv, `${settings.person||'Arbeitszeit'}_${settings.company||'Firma'}_Jahr_${y}.csv`, 'text/csv;charset=utf-8');
      toast("CSV Jahr exportiert");
    }
  
    async function exportPdfMonth(){
      const y = current.year, m = current.month;
      const startKey = toKey(y,m,1);
      const endKey = toKey(y,m,daysInMonth(y,m));
      const rows = await buildRowsForRange(startKey, endKey);
      const exportLabel = `Monat ${MONTHS[m-1]} ${y}`;
      const title = `Arbeitszeiterfassung`;
      const subtitle = `${settings.company || 'Firma'} ‚Ä¢ ${settings.person||''} ‚Ä¢ ${exportLabel} ‚Ä¢ Export: ${todayGerman()}`.replace(/\s+‚Ä¢\s+‚Ä¢/g,' ‚Ä¢').trim();
      const lines = rows.map(r=>{
    const time = (r.start && r.ende) ? `${r.start}-${r.ende}` : '‚Äî';
    const pause = (r.typ === 'Arbeitszeit') ? ` | Pause ${r.pause_h} h` : '';
    const hours = ` | Ist ${r.ist_h} h | Soll ${r.soll_h} h | Diff ${r.diff_h} h`;
    const ort = r.ort ? ` | ${r.ort}` : '';
    const notiz = r.notiz ? ` | ${r.notiz}` : '';
    return `${r.datum}  ${r.wochentag}  | ${r.typ} | ${time}${pause}${hours}${ort}${notiz}`;
  });
      const pdf = AZExport.createSimplePdf(title, subtitle, lines);
      AZExport.downloadBlob(pdf, `${settings.person||'Arbeitszeit'}_${settings.company||'Firma'}_${y}-${pad2(m)}.pdf`);
      toast("PDF Monat exportiert");
    }
  
    async function exportPdfYear(){
      const y = current.year;
      const startKey = toKey(y,1,1);
      const endKey = toKey(y,12,31);
      const rows = await buildRowsForRange(startKey, endKey);
      const exportLabel = `Jahr ${y}`;
      const title = `Arbeitszeiterfassung`;
      const subtitle = `${settings.company || 'Firma'} ‚Ä¢ ${settings.person||''} ‚Ä¢ ${exportLabel} ‚Ä¢ Export: ${todayGerman()}`.replace(/\s+‚Ä¢\s+‚Ä¢/g,' ‚Ä¢').trim();
      const lines = rows.map(r=>{
    const time = (r.start && r.ende) ? `${r.start}-${r.ende}` : '‚Äî';
    const pause = (r.typ === 'Arbeitszeit') ? ` | Pause ${r.pause_h} h` : '';
    const hours = ` | Ist ${r.ist_h} h | Soll ${r.soll_h} h | Diff ${r.diff_h} h`;
    const ort = r.ort ? ` | ${r.ort}` : '';
    const notiz = r.notiz ? ` | ${r.notiz}` : '';
    return `${r.datum}  ${r.wochentag}  | ${r.typ} | ${time}${pause}${hours}${ort}${notiz}`;
  });
      const pdf = AZExport.createSimplePdf(title, subtitle, lines);
      AZExport.downloadBlob(pdf, `${settings.person||'Arbeitszeit'}_${settings.company||'Firma'}_${y}.pdf`);
      toast("PDF Jahr exportiert");
    }
  
    async function backupJson(){
      const days = await AZDB.getAll();
      const out = {
        schema: 1,
        exportedAt: new Date().toISOString(),
        app: { version: window.__AZ_VERSION || "?", build: window.__AZ_BUILD || "?" },
        settings: {
          company: settings.company,
          person: settings.person,
          state: settings.state,
          assumption: settings.assumption,
          augsburg: settings.augsburg,
          vacationPerYear: settings.vacationPerYear
        },
        yearStartSaldo: {},
        days
      };
      // include yearStartSaldo keys >= 2025 found in settings store
      for(let y=APP_MIN_YEAR; y<=APP_MIN_YEAR+10; y++){
        const v = await AZDB.getSetting(getYearStartSaldoKey(y), null);
        if(v != null) out.yearStartSaldo[String(y)] = v;
      }
      try{
        await AZDB.setSetting(KEY_LAST_BACKUP_AT, Date.now());
      }catch(_e){}
      AZExport.downloadText(JSON.stringify(out, null, 2), `${settings.person||'Arbeitszeit'}_${settings.company||'Firma'}_Backup.json`, 'application/json;charset=utf-8');
      toast("Backup gespeichert");
      closeBackupModal();
    }
  
    async function restoreJsonFile(file){
      const text = await file.text();
      let data;
      try{ data = JSON.parse(text); }catch(e){ toast("JSON ung√ºltig"); return; }
      if(!data || !Array.isArray(data.days)){ toast("JSON Format falsch"); return; }
  
      // restore settings
      if(data.settings){
        await AZDB.setSetting('company', data.settings.company ?? 'Zaunteam');
        await AZDB.setSetting('person', data.settings.person ?? '');
        await AZDB.setSetting('state', data.settings.state ?? 'BY');
        await AZDB.setSetting('assumption', !!data.settings.assumption);
        await AZDB.setSetting('augsburg', !!data.settings.augsburg);
        await AZDB.setSetting('vacationPerYear', data.settings.vacationPerYear ?? 30);
      }
      if(data.yearStartSaldo){
        for(const [y,v] of Object.entries(data.yearStartSaldo)){
          const yr = parseInt(y,10);
          if(Number.isFinite(yr) && yr >= APP_MIN_YEAR){
            await AZDB.setSetting(getYearStartSaldoKey(yr), Number(v)||0);
          }
        }
      }
      // restore days (ignore <2025)
      let count=0;
      for(const rec of data.days){
        if(rec && typeof rec.date === 'string' && rec.date >= '2025-01-01'){
          await AZDB.setDay(rec);
          count++;
        }
      }
      toast(`Restore OK (${count} Tage)`);
      await loadSettings();
      $companyName.textContent = settings.company;
      await renderMonth();
    }
  
    // ---- CSV Import ----
    async function handleCsvFile(file){
      const text = await file.text();
      const parsed = AZExport.parseCsv(text);
  
      if(parsed.kind === 'year_summary'){
        const s = parsed.summary;
        if(!s){ toast((parsed.errors && parsed.errors[0]) || "CSV nicht erkannt"); return; }
        pendingImport = { kind:'year_summary', summary: s, fileName: file.name };
        $importMeta.textContent = `Jahres-CSV: ${s.year || '‚Äî'} | ${s.person || '‚Äî'} | ${s.company || '‚Äî'} | Datei: ${file.name}`;
        $importPreview.textContent = buildImportPreviewSummary(s);
        $importMode.innerHTML = `<option value="apply">√úbernehmen</option>`;
        $importMode.value = 'apply';
        $importModal.classList.remove('hidden');
        return;
      }
  
      if(parsed.kind === 'month_summary'){
        const s = parsed.summary;
        if(!s){ toast((parsed.errors && parsed.errors[0]) || "CSV nicht erkannt"); return; }
        pendingImport = { kind:'month_summary', summary: s, fileName: file.name };
        const mName = (s.month && MONTHS[s.month-1]) ? MONTHS[s.month-1] : (s.monthRow && s.monthRow.name) || '‚Äî';
        $importMeta.textContent = `Monats-CSV: ${mName} ${s.year || '‚Äî'} | ${s.person || '‚Äî'} | ${s.company || '‚Äî'} | Datei: ${file.name}`;
        $importPreview.textContent = buildImportPreviewSummary(s);
        $importMode.innerHTML = `<option value="apply">√úbernehmen</option>`;
        $importMode.value = 'apply';
        $importModal.classList.remove('hidden');
        return;
      }
  
      // daily
      const rows = parsed.rows || [];
      const errors = parsed.errors || [];
      if(errors.length){
        toast(errors[0]);
      }
      if(!rows.length){
        toast("Keine importierbaren Zeilen gefunden");
        return;
      }
  
      // meta
      const years = [...new Set(rows.map(r=>parseInt(r.date.slice(0,4),10)))].sort((a,b)=>a-b);
      const yms = [...new Set(rows.map(r=>(r.date||'').slice(0,7)).filter(Boolean))].sort();
      pendingImport = { kind:'daily', rows, years, fileName: file.name };
      if(yms.length === 1){
        const yy = parseInt(yms[0].slice(0,4),10);
        const mm = parseInt(yms[0].slice(5,7),10);
        const mName = (Number.isFinite(mm) && mm>=1 && mm<=12) ? MONTHS[mm-1] : yms[0];
        $importMeta.textContent = `Monat: ${mName} ${Number.isFinite(yy)?yy:''} | Zeilen: ${rows.length} | Datei: ${file.name}`;
      }else{
        $importMeta.textContent = `Zeilen: ${rows.length} | Jahre: ${years.join(", ")} | Datei: ${file.name}`;
      }
      $importPreview.textContent = buildImportPreview(rows.slice(0, 25));
      $importMode.innerHTML = `
        <option value="merge">Zusammenf√ºhren (empfohlen)</option>
        <option value="replace">Ersetzen</option>
      `;
      $importMode.value = 'merge';
      $importModal.classList.remove('hidden');
    }
  
    function buildImportPreview(rows){
      const lines = [];
      for(const r of rows){
        lines.push(`${r.date} | ${r.type||''} | ${r.start||''}-${r.end||''} | Pause ${r.breakH ?? ''} | ${r.place||''} | ${r.note||''}`);
      }
      return lines.join("\n");
    }
  
    function buildImportPreviewSummary(s){
      const lines = [];
  
      // Monats-CSV Vorschau
      if(s && s.kind === 'month_summary'){
        const mName = (s.month && MONTHS[s.month-1]) ? MONTHS[s.month-1] : (s.monthRow && s.monthRow.name) || '‚Äî';
        const r = s.monthRow || {};
        lines.push(`Stunden√ºbersicht eines Monats`);
        lines.push(`Name: ${s.person || '‚Äî'}`);
        lines.push(`Firma: ${s.company || '‚Äî'}`);
        lines.push(`Monat: ${mName} ${s.year || '‚Äî'}`);
        if(s.month === 1){
          lines.push(`Startsaldo (aus S. Vormonat): ${AZExport.formatNum(s.yearStartSaldo || 0)} h`);
        }
        lines.push("");
        lines.push(`Werte (Soll/Ist/Diff/Saldo):`);
        lines.push(`${mName}  Soll ${AZExport.formatNum(r.soll||0)}  Ist ${AZExport.formatNum(r.ist||0)}  Diff ${AZExport.formatNum(r.diff||0)}  Saldo ${AZExport.formatNum(r.saldo||0)}`);
        lines.push("");
        lines.push("Hinweis: Diese Monats-CSV f√ºllt keine Tageszeiten. Sie wird als Monatswert im Jahres-Import gespeichert und in Soll/Ist/Saldo angezeigt.");
        return lines.join("\n");
      }
  
      lines.push(`Stunden√ºbersicht eines Jahres`);
      lines.push(`Name: ${s.person || '‚Äî'}`);
      lines.push(`Firma: ${s.company || '‚Äî'}`);
      lines.push(`Jahr: ${s.year || '‚Äî'}`);
      lines.push(`Startsaldo (aus Januar S. Vormonat): ${AZExport.formatNum(s.yearStartSaldo || 0)} h`);
      lines.push(`Monate gefunden: ${Array.isArray(s.months)?s.months.length:0}`);
      if(Array.isArray(s.months) && s.months.length){
        lines.push("");
        lines.push("Monatswerte (Soll/Ist/Diff/Saldo):");
        for(const m of s.months){
          const mn = String(m.name||"").padEnd(10,' ');
          lines.push(`${mn}  Soll ${AZExport.formatNum(m.soll||0)}  Ist ${AZExport.formatNum(m.ist||0)}  Diff ${AZExport.formatNum(m.diff||0)}  Saldo ${AZExport.formatNum(m.saldo||0)}`);
        }
        if(s.total){
          lines.push("");
          lines.push(`Total: Soll ${AZExport.formatNum(s.total.soll||0)} | Ist ${AZExport.formatNum(s.total.ist||0)} | Diff ${AZExport.formatNum(s.total.diff||0)} | Saldo ${AZExport.formatNum(s.total.saldo||0)}`);
        }
      }
      if(s.counts && s.counts.totalByKey){
        const t = s.counts.totalByKey;
        const vac = (typeof t.ferien_urlaub==='number') ? t.ferien_urlaub : null;
        const sick = (typeof t.krank==='number') ? t.krank : null;
        lines.push("");
        lines.push(`Tage-Statistik (Total): Urlaub ${vac!=null?vac:'‚Äî'} | Krank ${sick!=null?sick:'‚Äî'} | Feiertage ${typeof t.feiertag==='number'?t.feiertag:'‚Äî'}`);
      }
      lines.push("");
      lines.push("Hinweis: Diese CSV enth√§lt eine Jahres√ºbersicht (Monatswerte + Tages-Statistik). Tageszeiten werden dadurch nicht automatisch bef√ºllt.");
      return lines.join("\n");
    }
  
    async function confirmImport(){
      if(!pendingImport) return;
  
      // 1) Jahres-CSV (Jahres√ºbersicht: Monatswerte + Tages-Statistik)
      if(pendingImport.kind === 'year_summary'){
        const s = pendingImport.summary;
        const y = parseInt(String(s.year||''), 10);
        if(!Number.isFinite(y) || y < APP_MIN_YEAR){
          toast("Jahr ung√ºltig (min. 2025)");
          return;
        }
  
        const ys = Number(s.yearStartSaldo || 0);
        await AZDB.setSetting(getYearStartSaldoKey(y), Number.isFinite(ys) ? ys : 0);
  
        // komplette Jahres√ºbersicht f√ºr Anzeige/Fallback speichern
        try{ await AZDB.setSetting('useYearSummaryMonthly', true); settings.useYearSummaryMonthly = true; }catch(e){ /* ignore */ }
  
        try{
          await AZDB.setSetting('yearSummary_' + y, JSON.stringify(s));
        }catch(e){ /* ignore */ }
  
        const curPerson = await AZDB.getSetting('person', '');
        const curCompany = await AZDB.getSetting('company', 'Zaunteam');
        if(!curPerson && s.person){
          await AZDB.setSetting('person', s.person);
        }
        if((!curCompany || curCompany === 'Zaunteam') && s.company){
          await AZDB.setSetting('company', s.company);
        }
  
        pendingImport = null;
        $importModal.classList.add('hidden');
        toast(`Jahres-CSV √ºbernommen (${y})`);
        try{ invalidateYearCache(y); }catch(e){ /* ignore */ }
        try{ current.year = y; if(current.month < 1 || current.month > 12) current.month = 1; openDateKey = null; }catch(e){ /* ignore */ }
        await loadSettings();
        await renderMonth();
        return;
      }
  
      // 1b) Monats-CSV (Monatswerte -> wird in yearSummary_<year> gemerged)
      if(pendingImport.kind === 'month_summary'){
        const s = pendingImport.summary;
        const y = parseInt(String(s.year||''), 10);
        const m = parseInt(String(s.month||''), 10);
        if(!Number.isFinite(y) || y < APP_MIN_YEAR){
          toast("Jahr ung√ºltig (min. 2025)");
          return;
        }
        if(!Number.isFinite(m) || m < 1 || m > 12){
          toast("Monat ung√ºltig");
          return;
        }
  
        let ys = null;
        try{
          const raw = await AZDB.getSetting('yearSummary_' + y, null);
          if(raw) ys = JSON.parse(raw);
        }catch(e){ ys = null; }
  
        if(!ys || typeof ys !== 'object'){
          ys = { kind:'year_summary', year:y, person:s.person||'', company:s.company||'', yearStartSaldo:0, months:[], total:null, counts:null };
        }
        if(!ys.person && s.person) ys.person = s.person;
        if(!ys.company && s.company) ys.company = s.company;
  
        const mr = s.monthRow || {};
        const entry = {
          month: m,
          name: mr.name || (MONTHS[m-1] || String(m)),
          soll: Number(mr.soll||0),
          ist: Number(mr.ist||0),
          diff: Number(mr.diff||0),
          carry: Number(mr.carry||0),
          paidOvertime: Number(mr.paidOvertime||0),
          saldo: Number(mr.saldo||0)
        };
        if(!Array.isArray(ys.months)) ys.months = [];
        const idx = ys.months.findIndex(x => Number(x.month) === m);
        if(idx >= 0) ys.months[idx] = {...ys.months[idx], ...entry};
        else ys.months.push(entry);
        ys.months = ys.months
          .filter(x=>Number.isFinite(Number(x.month)) && Number(x.month)>=1 && Number(x.month)<=12)
          .sort((a,b)=>Number(a.month)-Number(b.month));
  
        if(m === 1){
          const ysSaldo = Number(s.yearStartSaldo || entry.carry || 0);
          ys.yearStartSaldo = Number.isFinite(ysSaldo) ? ysSaldo : 0;
          await AZDB.setSetting(getYearStartSaldoKey(y), ys.yearStartSaldo);
        }
  
        try{ await AZDB.setSetting('useYearSummaryMonthly', true); settings.useYearSummaryMonthly = true; }catch(e){ /* ignore */ }
        try{ await AZDB.setSetting('yearSummary_' + y, JSON.stringify(ys)); }catch(e){ /* ignore */ }
  
        const curPerson = await AZDB.getSetting('person', '');
        const curCompany = await AZDB.getSetting('company', 'Zaunteam');
        if(!curPerson && ys.person){ await AZDB.setSetting('person', ys.person); }
        if((!curCompany || curCompany === 'Zaunteam') && ys.company){ await AZDB.setSetting('company', ys.company); }
  
        pendingImport = null;
        $importModal.classList.add('hidden');
        toast(`Monats-CSV √ºbernommen (${MONTHS[m-1]} ${y})`);
        try{ invalidateYearCache(y); }catch(e){ /* ignore */ }
        try{ current.year = y; current.month = m; openDateKey = null; }catch(e){ /* ignore */ }
        await loadSettings();
        await renderMonth();
        return;
      }
  
      // 2) Daily CSV
      const mode = $importMode.value;
      const rows = pendingImport.rows;
      const years = pendingImport.years;
  
      if(mode === 'replace'){
        for(const y of years){
          if(y < APP_MIN_YEAR) continue;
          const startKey = toKey(y,1,1);
          const endKey = toKey(y,12,31);
          const existing = await AZDB.getRange(startKey, endKey);
          for(const rec of existing){
            await AZDB.deleteDay(rec.date);
          }
        }
      }
  
      let written=0;
      for(const r of rows){
        const key = r.date;
        const tmp = normalizeRecord(key, null);
        const type = r.type || tmp.type;
        const rec = {
          date: key,
          type: type,
          start: (type==='work' ? (r.start||"") : ""),
          end: (type==='work' ? (r.end||"") : ""),
          breakH: (type==='work' ? (Number.isFinite(r.breakH) ? r.breakH : (r.breakH!=null?Number(r.breakH):0.5)) : 0),
          place: r.place || "",
          note: r.note || "",
          updatedAt: Date.now()
        };
        if(type==='work'){
          if(!Number.isFinite(rec.breakH) || rec.breakH<0) rec.breakH = 0.5;
        }else{
          rec.breakH = 0;
        }
        await AZDB.setDay(rec);
        written++;
      }
      pendingImport = null;
      $importModal.classList.add('hidden');
      toast(`Import OK (${written} Tage)`);
      try{
        if(Array.isArray(years)) for(const y of years) invalidateYearCache(y);
      }catch(e){ /* ignore */ }
      // Nach Import automatisch in den importierten Monat springen (damit man sofort etwas sieht)
      try{
        if(Array.isArray(rows) && rows.length){
          const dates = rows.map(r=>r.date).filter(Boolean).sort();
          const dk = dates[0];
          const yy = parseInt(String(dk).slice(0,4),10);
          const mm = parseInt(String(dk).slice(5,7),10);
          if(Number.isFinite(yy) && yy >= APP_MIN_YEAR && Number.isFinite(mm) && mm>=1 && mm<=12){
            current.year = yy;
            current.month = mm;
            openDateKey = null;
          }
        }
      }catch(e){ /* ignore */ }
      await renderMonth();
    }
  
    function closeImport(){
      $importModal.classList.add('hidden');
      pendingImport = null;
      try{ if($fileImportCsv) $fileImportCsv.value = ""; }catch(_e){}
    }
  
    function openBackupModal(text){
      if(!$backupModal) return;
      if($backupHint) $backupHint.textContent = text || 'Backup empfohlen';
      $backupModal.classList.remove('hidden');
    }
    function closeBackupModal(){
      if(!$backupModal) return;
      $backupModal.classList.add('hidden');
    }
  
  
    // ---- Update / Cache ----
    async function cacheReset(){
      try{
        if('serviceWorker' in navigator){
          const regs = await navigator.serviceWorker.getRegistrations();
          for(const r of regs) await r.unregister();
        }
        if('caches' in window){
          const keys = await caches.keys();
          for(const k of keys) await caches.delete(k);
        }
        toast("Cache/Update-Reset OK ‚Äì lade neu‚Ä¶");
        setTimeout(()=>location.reload(), 600);
      }catch(e){
        toast("Reset fehlgeschlagen");
      }
    }
  
    async function checkUpdate(){
      try{
        const res = await fetch(`version.json?t=${Date.now()}`, {cache:'no-store'});
        if(!res.ok) throw new Error("no version");
        const v = await res.json();
        const curV = window.__AZ_VERSION || "?";
        if(v.version && v.version !== curV){
          $updateInfo.textContent = `Neue Version gefunden: ${v.version} (Build ${v.build||'‚Äî'})`;
          $updateBanner.classList.remove('hidden');
          $updateText.textContent = `Update verf√ºgbar: ${v.version}`;
          toast("Update verf√ºgbar");
          // trigger SW update
          const reg = await navigator.serviceWorker.getRegistration();
          if(reg) reg.update();
        }else{
          $updateInfo.textContent = `Aktuell: ${curV} (Build ${window.__AZ_BUILD||'‚Äî'})`;
          toast("Kein Update gefunden");
        }
      }catch(e){
        if(!navigator.onLine){
          $updateInfo.textContent = "Offline: Update-Check nicht m√∂glich";
          return;
        }
        $updateInfo.textContent = "Update-Check fehlgeschlagen";
        toast("Update-Check fehlgeschlagen");
      }
    }
  
    function showUpdateBanner(text){
      $updateText.textContent = text || "Update verf√ºgbar";
      $updateBanner.classList.remove('hidden');
    }
  
    async function updateNow(){
      if(!('serviceWorker' in navigator)) return location.reload();
      const reg = await navigator.serviceWorker.getRegistration();
      if(reg && reg.waiting){
        reg.waiting.postMessage({type:'SKIP_WAITING'});
        toast("Update wird aktiviert‚Ä¶");
        return;
      }
      // fallback: hard reload
      toast("Neu laden‚Ä¶");
      setTimeout(()=>location.reload(), 400);
    }
  
    function _isStandalone(){
      try{
        // iOS uses navigator.standalone
        if(window.navigator && window.navigator.standalone) return true;
        return window.matchMedia && window.matchMedia('(display-mode: standalone)').matches;
      }catch(_e){
        return false;
      }
    }
  
    function refreshInstallInfo(extra){
      try{
        const parts = [];
        parts.push('Secure: ' + (window.isSecureContext ? 'yes' : 'no'));
        parts.push('SW: ' + (('serviceWorker' in navigator) ? 'yes' : 'no'));
        parts.push('SW ctrl: ' + ((navigator.serviceWorker && navigator.serviceWorker.controller) ? 'yes' : 'no'));
        parts.push('Standalone: ' + (_isStandalone() ? 'yes' : 'no'));
        parts.push('Prompt: ' + (deferredInstallPrompt ? 'ready' : 'no'));
        if(extra) parts.push(String(extra));
        if($installInfo) $installInfo.textContent = parts.join(' ‚Ä¢ ');
        if($btnInstallApp){
          if(deferredInstallPrompt) $btnInstallApp.classList.remove('hidden');
          else $btnInstallApp.classList.add('hidden');
        }
      }catch(_e){}
    }
  
    function initInstallHooks(){
      try{
        window.addEventListener('beforeinstallprompt', (e)=>{
          e.preventDefault();
          deferredInstallPrompt = e;
          refreshInstallInfo('beforeinstallprompt');
        });
  
        window.addEventListener('appinstalled', ()=>{
          deferredInstallPrompt = null;
          refreshInstallInfo('installed');
          try{ toast('App installiert'); }catch(_e){}
        });
  
        if($btnInstallApp){
          $btnInstallApp.addEventListener('click', async ()=>{
            if(!deferredInstallPrompt){
              refreshInstallInfo('no prompt');
              return;
            }
            const p = deferredInstallPrompt;
            deferredInstallPrompt = null;
            refreshInstallInfo('prompting');
            try{
              await p.prompt();
              const choice = await p.userChoice;
              refreshInstallInfo('choice: ' + ((choice && choice.outcome) ? choice.outcome : 'unknown'));
            }catch(e){
              refreshInstallInfo('prompt error');
            }
          });
        }
  
        refreshInstallInfo();
      }catch(_e){}
    }
  
    function registerSW(){
      if(!('serviceWorker' in navigator)) return;
      // iOS (and sometimes other browsers) cannot (re)register a SW while fully offline
      // unless a controller is already active. In that case the app may still run from
      // cache, so don't show a scary error.
      const hasController = !!navigator.serviceWorker.controller;
      if(!navigator.onLine && !hasController){
        try{
          const el = document.getElementById('updateInfo');
          if(el && !el.textContent.includes('Offline')){
            el.textContent = (el.textContent ? (el.textContent+' ‚Ä¢ ') : '') + 'Offline (SW wird beim n√§chsten Online-Start aktiviert)';
          }
        }catch(_e){}
        return;
      }
  
      navigator.serviceWorker.register('./sw.js', {scope:'./'}).then((reg)=>{
        // listen for updates
        reg.addEventListener('updatefound', ()=>{
          const nw = reg.installing;
          if(!nw) return;
          nw.addEventListener('statechange', ()=>{
            if(nw.state === 'installed'){
              if(navigator.serviceWorker.controller){
                showUpdateBanner("Update verf√ºgbar");
              }
            }
          });
        });
  
              // offline-ready indicator
        navigator.serviceWorker.ready.then(()=>{
          window.__AZ_OFFLINE_READY = true;
          try{ refreshInstallInfo('sw ready'); }catch(_e){}
          try{
            if($updateInfo && !$updateInfo.textContent.includes('Offline')){
              $updateInfo.textContent = ($updateInfo.textContent ? ($updateInfo.textContent + ' ‚Ä¢ ') : '') + 'Offline bereit';
            }
          }catch(_e){}
          try{
            if($appVersion && !$appVersion.textContent.includes('offline')){
              $appVersion.textContent = ($appVersion.textContent ? ($appVersion.textContent + ' ‚Ä¢ ') : '') + 'offline';
            }
          }catch(_e){}
        }).catch(()=>{});
  
  
  navigator.serviceWorker.addEventListener('controllerchange', ()=>{
          try{ refreshInstallInfo('sw controller'); }catch(_e){}
          // new version active
          location.reload();
        });
      }).catch((err)=>{
        console.warn('SW register failed', err);
        // If we're offline, this is expected on some platforms; don't alarm the user.
        if(!navigator.onLine) return;
        try{ toast('Offline/Cache nicht verf√ºgbar (Service Worker Fehler)'); }catch(_e){}
      });
    }
  
    // ---- Navigation ----
    function gotoToday(){
      const d = new Date();
      const y = Math.max(APP_MIN_YEAR, d.getFullYear());
      const m = d.getMonth()+1;
      current.year = y; current.month = m;
      const k = toKey(y,m,d.getDate());
      openDateKey = k;
      renderMonth();
      // highlight in list
      setTimeout(()=>scrollToDay(k), 60);
    }
  
    function scrollToDay(key){
      const el = $dayList.querySelector(`[data-date="${key}"]`);
      if(el) el.scrollIntoView({block:'center', behavior:'smooth'});
    }
  
    function prevMonth(){
      let y=current.year, m=current.month;
      m -= 1;
      if(m<1){ y -= 1; m=12; }
      if(y < APP_MIN_YEAR){ toast("Vor 2025 ist deaktiviert"); return; }
      current.year=y; current.month=m;
      renderMonth();
    }
    function nextMonth(){
      let y=current.year, m=current.month;
      m += 1;
      if(m>12){ y += 1; m=1; }
      current.year=y; current.month=m;
      renderMonth();
    }
  
    // ---- Bindings ----
    function bind(){
      els('btnSettings').addEventListener('click', openSettings);
      els('btnCloseSettings').addEventListener('click', closeSettings);
      els('btnSaveSettings').addEventListener('click', saveSettings);
  
      els('btnPrevMonth').addEventListener('click', prevMonth);
      els('btnNextMonth').addEventListener('click', nextMonth);
      els('btnToday').addEventListener('click', gotoToday);
      els('btnYearView').addEventListener('click', openYearView);
      els('btnBackToMonth').addEventListener('click', ()=>renderMonth());
  
      // update banner
      els('btnUpdateNow').addEventListener('click', updateNow);
  
      // settings extras
      els('btnCacheReset').addEventListener('click', cacheReset);
      els('btnCheckUpdate').addEventListener('click', checkUpdate);
  
      // export
      els('btnExportCsvMonth').addEventListener('click', exportCsvMonth);
      els('btnExportCsvYear').addEventListener('click', exportCsvYear);
      els('btnExportPdfMonth').addEventListener('click', exportPdfMonth);
      els('btnExportPdfYear').addEventListener('click', exportPdfYear);
      els('btnExportHandyMonth').addEventListener('click', exportHandyMonth);
      els('btnBackupJson').addEventListener('click', backupJson);
      // auto-backup reminder modal
      const _bn = els('btnBackupNow'); if(_bn) _bn.addEventListener('click', backupJson);
      const _bl = els('btnBackupLater'); if(_bl) _bl.addEventListener('click', closeBackupModal);
      const _bc = els('btnCloseBackup'); if(_bc) _bc.addEventListener('click', closeBackupModal);
  
      els('btnRestoreJson').addEventListener('click', ()=>els('fileRestoreJson').click());
      els('fileRestoreJson').addEventListener('change', async (e)=>{
        const f = e.target.files && e.target.files[0];
        e.target.value = "";
        if(f) await restoreJsonFile(f);
      });
  
      // CSV import
      $fileImportCsv.addEventListener('change', async (e)=>{
        const f = e.target.files && e.target.files[0];
        e.target.value = "";
        if(f) await handleCsvFile(f);
      });
  
      // import modal
      els('btnCloseImport').addEventListener('click', closeImport);
      const $btnCancelImport = els('btnCancelImport');
      if($btnCancelImport) $btnCancelImport.addEventListener('click', closeImport);
      els('btnConfirmImport').addEventListener('click', confirmImport);
  
      // live holiday preview in settings
      $setState.addEventListener('change', refreshHolidayPreview);
      $setAssumption.addEventListener('change', refreshHolidayPreview);
      $setAugsburg.addEventListener('change', refreshHolidayPreview);
    }
  
    // ---- Init ----
    async function init(){
      // show version
      try{
        const res = await fetch(`version.json?t=${Date.now()}`, {cache:'no-store'});
        if(res.ok){
          const v = await res.json();
          window.__AZ_VERSION = v.version;
          window.__AZ_BUILD = v.build;
          $appVersion.textContent = `v${v.version} ‚Ä¢ ${v.build}`;
        }else{
          $appVersion.textContent = "";
        }
      }catch(e){
        $appVersion.textContent = "";
      }
  
      fillStateSelect();
      await AZDB.cleanupBefore2025();
      await loadSettings();
  
      const now = new Date();
      current.year = Math.max(APP_MIN_YEAR, now.getFullYear());
      current.month = now.getMonth()+1;
  
      $companyName.textContent = settings.company;
  
      bind();
      registerSW();
      initInstallHooks();
      await renderMonth();
      // remind for backup (weekly)
      setTimeout(()=>{ maybeBackupReminder(); }, 600);
    }
  
    // global safe init
    init().catch((e)=>{
      console.error(e);
      document.body.innerHTML = `
        <div style="padding:16px;font-family:system-ui">
          <div style="border:3px solid #C31120;border-radius:12px;padding:12px;background:#fff">
            <b>Fehler beim Starten.</b><br/>
            Script error.<br/><br/>
            <button id="hardReload" style="padding:10px 12px;border-radius:10px;border:1px solid #bbb;font-weight:800">Neu laden</button>
            <button id="hardReset" style="padding:10px 12px;border-radius:10px;border:1px solid #8A0F18;background:#C31120;color:#fff;font-weight:800;margin-left:8px">Cache/Update-Reset</button>
            <pre style="white-space:pre-wrap;margin-top:10px;font-size:12px;opacity:.8">${String(e && e.stack || e)}</pre>
          </div>
        </div>
      `;
      setTimeout(()=>{
        const r = document.getElementById('hardReload');
        const rs = document.getElementById('hardReset');
        if(r) r.onclick = ()=>location.reload();
        if(rs) rs.onclick = async ()=>{
          try{
            if('serviceWorker' in navigator){
              const regs = await navigator.serviceWorker.getRegistrations();
              for(const reg of regs) await reg.unregister();
            }
            if('caches' in window){
              const keys = await caches.keys();
              for(const k of keys) await caches.delete(k);
            }
          }catch(_){}
          location.reload();
        };
      }, 50);
    });
  
  })();
  
  
  </script>
</body>
</html>
